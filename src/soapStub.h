/* soapStub.h
   Generated by gSOAP 2.8.117 for /home/jbennett/src/zoneminder/build/generated/bindings.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_wsa5	"http://www.w3.org/2005/08/addressing"
#define SOAP_NAMESPACE_OF_tev	"http://www.onvif.org/ver10/events/wsdl"
#define SOAP_NAMESPACE_OF_wsrfrw	"http://docs.oasis-open.org/wsrf/rw-2"
#define SOAP_NAMESPACE_OF_wsrfr	"http://docs.oasis-open.org/wsrf/r-2"
#define SOAP_NAMESPACE_OF_wsrfbf	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_wsnt	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_wstop	"http://docs.oasis-open.org/wsn/t-1"
#define SOAP_NAMESPACE_OF_wsu	"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
#define SOAP_NAMESPACE_OF_wsse	"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
#define SOAP_NAMESPACE_OF_ds	"http://www.w3.org/2000/09/xmldsig#"
#define SOAP_NAMESPACE_OF_xenc	"http://www.w3.org/2001/04/xmlenc#"
#define SOAP_NAMESPACE_OF_wsc	"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512"
#define SOAP_NAMESPACE_OF_saml1	"urn:oasis:names:tc:SAML:1.0:assertion"
#define SOAP_NAMESPACE_OF_saml2	"urn:oasis:names:tc:SAML:2.0:assertion"

#ifndef soapStub_H
#define soapStub_H
#ifndef WITH_NONAMESPACES
#define WITH_NONAMESPACES
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 208117
# error "GSOAP VERSION 208117 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* wsa5.h:96 */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (19)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType {
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* wsa5.h:104 */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (20)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType {
	wsa5__InvalidAddressingHeader = 0,
	wsa5__InvalidAddress = 1,
	wsa5__InvalidEPR = 2,
	wsa5__InvalidCardinality = 3,
	wsa5__MissingAddressInEPR = 4,
	wsa5__DuplicateMessageID = 5,
	wsa5__ActionMismatch = 6,
	wsa5__MessageAddressingHeaderRequired = 7,
	wsa5__DestinationUnreachable = 8,
	wsa5__ActionNotSupported = 9,
	wsa5__EndpointUnavailable = 10
};
#endif

/* wsa5.h:254 */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (40)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter {
	_wsa5__IsReferenceParameter__false = 0,
	_wsa5__IsReferenceParameter__true = 1
};
#endif

/* wsu.h:67 */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (295)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault {
	wsu__MessageExpired = 0
};
#endif

/* wsse.h:117 */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (298)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum {
	wsse__UnsupportedSecurityToken = 0,
	wsse__UnsupportedAlgorithm = 1,
	wsse__InvalidSecurity = 2,
	wsse__InvalidSecurityToken = 3,
	wsse__FailedAuthentication = 4,
	wsse__FailedCheck = 5,
	wsse__SecurityTokenUnavailable = 6
};
#endif

/* wsc.h:63 */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (375)
/* wsc:FaultCodeType */
enum wsc__FaultCodeType {
	wsc__BadContextToken = 0,
	wsc__UnsupportedContextToken = 1,
	wsc__UnknownDerivationSource = 2,
	wsc__RenewNeeded = 3,
	wsc__UnableToRenew = 4
};
#endif

/* saml1.h:146 */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (406)
/* saml1:DecisionType */
enum saml1__DecisionType {
	saml1__DecisionType__Permit = 0,
	saml1__DecisionType__Deny = 1,
	saml1__DecisionType__Indeterminate = 2
};
#endif

/* saml2.h:155 */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (485)
/* saml2:DecisionType */
enum saml2__DecisionType {
	saml2__DecisionType__Permit = 0,
	saml2__DecisionType__Deny = 1,
	saml2__DecisionType__Indeterminate = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* dom.h:62 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (9)
typedef struct soap_dom_element xsd__anyType;
#endif

/* dom.h:65 */
#ifndef SOAP_TYPE_xsd__anyAttribute
#define SOAP_TYPE_xsd__anyAttribute (11)
typedef struct soap_dom_attribute xsd__anyAttribute;
#endif

/* custom/struct_timeval.h:77 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (385)
typedef struct timeval xsd__dateTime;
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:187 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (58)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

struct wsa5__EndpointReferenceType;	/* wsa5.h:65 */
struct wsa5__ReferenceParametersType;	/* wsa5.h:68 */
struct wsa5__MetadataType;	/* wsa5.h:71 */
struct wsa5__ProblemActionType;	/* wsa5.h:86 */
struct wsa5__RelatesToType;	/* wsa5.h:74 */
struct chan__ChannelInstanceType;	/* wsa5.h:260 */
class tev__Capabilities;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:217 */
class tev__EventBrokerConfig;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:219 */
class _tev__GetServiceCapabilities;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:221 */
class _tev__GetServiceCapabilitiesResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:223 */
class _tev__CreatePullPointSubscription_SubscriptionPolicy;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:764 */
class _tev__CreatePullPointSubscription;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:225 */
class _tev__CreatePullPointSubscriptionResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:227 */
class _tev__PullMessages;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:229 */
class _tev__PullMessagesResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:231 */
class _tev__PullMessagesFaultResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:233 */
class _tev__Seek;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:235 */
class _tev__SeekResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:237 */
class _tev__SetSynchronizationPoint;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:239 */
class _tev__SetSynchronizationPointResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:241 */
class _tev__GetEventProperties;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:243 */
class _tev__GetEventPropertiesResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:245 */
class _tev__AddEventBroker;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:250 */
class _tev__AddEventBrokerResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:252 */
class _tev__DeleteEventBroker;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:254 */
class _tev__DeleteEventBrokerResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:256 */
class _tev__GetEventBrokers;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:258 */
class _tev__GetEventBrokersResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:260 */
class _wsrfbf__BaseFaultType_ErrorCode;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:1375 */
class _wsrfbf__BaseFaultType_Description;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:1398 */
class _wsrfbf__BaseFaultType_FaultCause;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:1416 */
class wsrfbf__BaseFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:266 */
class wsnt__QueryExpressionType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:268 */
class wsnt__TopicExpressionType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:270 */
class wsnt__FilterType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:272 */
class wsnt__SubscriptionPolicyType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:274 */
class _wsnt__NotificationMessageHolderType_Message;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:1602 */
class wsnt__NotificationMessageHolderType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:276 */
class _wsnt__NotificationProducerRP;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:318 */
class _wsnt__SubscriptionManagerRP;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:320 */
class _wsnt__Notify;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:322 */
class _wsnt__UseRaw;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:324 */
class _wsnt__Subscribe_SubscriptionPolicy;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:1755 */
class _wsnt__Subscribe;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:326 */
class _wsnt__SubscribeResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:328 */
class _wsnt__GetCurrentMessage;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:330 */
class _wsnt__GetCurrentMessageResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:332 */
class _wsnt__GetMessages;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:334 */
class _wsnt__GetMessagesResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:336 */
class _wsnt__DestroyPullPoint;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:338 */
class _wsnt__DestroyPullPointResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:340 */
class _wsnt__CreatePullPoint;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:342 */
class _wsnt__CreatePullPointResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:344 */
class _wsnt__Renew;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:346 */
class _wsnt__RenewResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:348 */
class _wsnt__Unsubscribe;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:350 */
class _wsnt__UnsubscribeResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:352 */
class _wsnt__PauseSubscription;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:354 */
class _wsnt__PauseSubscriptionResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:356 */
class _wsnt__ResumeSubscription;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:358 */
class _wsnt__ResumeSubscriptionResponse;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:360 */
class wstop__Documentation;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:362 */
class wstop__ExtensibleDocumented;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:364 */
class wstop__QueryExpressionType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:366 */
class wsrfr__ResourceUnknownFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:262 */
class wsrfr__ResourceUnavailableFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:264 */
class wsnt__SubscribeCreationFailedFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:278 */
class wsnt__InvalidFilterFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:280 */
class wsnt__TopicExpressionDialectUnknownFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:282 */
class wsnt__InvalidTopicExpressionFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:284 */
class wsnt__TopicNotSupportedFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:286 */
class wsnt__MultipleTopicsSpecifiedFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:288 */
class wsnt__InvalidProducerPropertiesExpressionFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:290 */
class wsnt__InvalidMessageContentExpressionFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:292 */
class wsnt__UnrecognizedPolicyRequestFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:294 */
class wsnt__UnsupportedPolicyRequestFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:296 */
class wsnt__NotifyMessageNotSupportedFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:298 */
class wsnt__UnacceptableInitialTerminationTimeFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:300 */
class wsnt__NoCurrentMessageOnTopicFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:302 */
class wsnt__UnableToGetMessagesFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:304 */
class wsnt__UnableToDestroyPullPointFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:306 */
class wsnt__UnableToCreatePullPointFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:308 */
class wsnt__UnacceptableTerminationTimeFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:310 */
class wsnt__UnableToDestroySubscriptionFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:312 */
class wsnt__PauseFailedFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:314 */
class wsnt__ResumeFailedFaultType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:316 */
class _wstop__TopicNamespaceType_Topic;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:4645 */
class wstop__TopicNamespaceType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:368 */
class wstop__TopicType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:370 */
class wstop__TopicSetType;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:372 */
struct __tev__PullMessages;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5266 */
struct __tev__Seek;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5347 */
struct __tev__SetSynchronizationPoint;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5430 */
struct __tev__Unsubscribe;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5508 */
struct __tev__GetServiceCapabilities;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5577 */
struct __tev__CreatePullPointSubscription;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5687 */
struct __tev__GetEventProperties;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5762 */
struct __tev__AddEventBroker;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5833 */
struct __tev__DeleteEventBroker;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5902 */
struct __tev__GetEventBrokers;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5971 */
struct __tev__Renew;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6044 */
struct __tev__Unsubscribe_;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6117 */
struct __tev__Subscribe;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6220 */
struct __tev__GetCurrentMessage;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6305 */
struct __tev__Notify;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6368 */
struct __tev__GetMessages;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6441 */
struct __tev__DestroyPullPoint;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6514 */
struct __tev__Notify_;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6577 */
struct __tev__CreatePullPoint;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6647 */
struct __tev__Renew_;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6720 */
struct __tev__Unsubscribe__;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6793 */
struct __tev__PauseSubscription;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6866 */
struct __tev__ResumeSubscription;	/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6939 */
struct _wsu__Timestamp;	/* wsu.h:77 */
struct wsse__EncodedString;	/* wsse.h:74 */
struct _wsse__UsernameToken;	/* wsse.h:145 */
struct _wsse__BinarySecurityToken;	/* wsse.h:158 */
struct _wsse__Reference;	/* wsse.h:168 */
struct _wsse__Embedded;	/* wsse.h:176 */
struct _wsse__KeyIdentifier;	/* wsse.h:185 */
struct _wsse__SecurityTokenReference;	/* wsse.h:195 */
struct ds__KeyInfoType;	/* xenc.h:38 */
struct ds__SignatureType;	/* ds.h:50 */
struct _c14n__InclusiveNamespaces;	/* c14n.h:24 */
struct ds__TransformType;	/* ds.h:77 */
struct ds__SignedInfoType;	/* ds.h:50 */
struct ds__CanonicalizationMethodType;	/* ds.h:63 */
struct ds__SignatureMethodType;	/* ds.h:66 */
struct ds__ReferenceType;	/* ds.h:69 */
struct ds__TransformsType;	/* ds.h:72 */
struct ds__DigestMethodType;	/* ds.h:83 */
struct ds__KeyValueType;	/* ds.h:88 */
struct ds__RetrievalMethodType;	/* ds.h:89 */
struct ds__X509DataType;	/* wsse.h:198 */
struct ds__X509IssuerSerialType;	/* ds.h:106 */
struct ds__DSAKeyValueType;	/* ds.h:127 */
struct ds__RSAKeyValueType;	/* ds.h:130 */
struct xenc__EncryptionPropertyType;	/* xenc.h:101 */
struct xenc__EncryptedType;	/* xenc.h:70 */
struct xenc__EncryptionMethodType;	/* xenc.h:73 */
struct xenc__CipherDataType;	/* xenc.h:76 */
struct xenc__CipherReferenceType;	/* xenc.h:79 */
struct xenc__TransformsType;	/* xenc.h:82 */
struct xenc__AgreementMethodType;	/* xenc.h:91 */
struct xenc__ReferenceType;	/* xenc.h:94 */
struct xenc__EncryptionPropertiesType;	/* xenc.h:97 */
struct __xenc__union_ReferenceList;	/* xenc.h:253 */
struct _xenc__ReferenceList;	/* xenc.h:106 */
struct xenc__EncryptedDataType;	/* xenc.h:85 */
struct xenc__EncryptedKeyType;	/* xenc.h:39 */
struct wsc__SecurityContextTokenType;	/* wsc.h:88 */
union _wsc__union_DerivedKeyTokenType;	/* wsc.h:121 */
struct __wsc__DerivedKeyTokenType_sequence;	/* wsc.h:117 */
struct wsc__DerivedKeyTokenType;	/* wsc.h:110 */
struct wsc__PropertiesType;	/* wsc.h:114 */
struct __saml1__union_AssertionType;	/* saml1.h:181 */
struct saml1__AssertionType;	/* saml1.h:75 */
struct __saml1__union_ConditionsType;	/* saml1.h:224 */
struct saml1__ConditionsType;	/* saml1.h:78 */
struct saml1__ConditionAbstractType;	/* saml1.h:81 */
struct __saml1__union_AdviceType;	/* saml1.h:270 */
struct saml1__AdviceType;	/* saml1.h:90 */
struct saml1__StatementAbstractType;	/* saml1.h:93 */
struct saml1__SubjectType;	/* saml1.h:99 */
struct saml1__SubjectConfirmationType;	/* saml1.h:105 */
struct saml1__SubjectLocalityType;	/* saml1.h:111 */
struct saml1__AuthorityBindingType;	/* saml1.h:114 */
struct __saml1__union_EvidenceType;	/* saml1.h:395 */
struct saml1__EvidenceType;	/* saml1.h:123 */
struct saml1__AttributeDesignatorType;	/* saml1.h:129 */
struct saml1__AudienceRestrictionConditionType;	/* saml1.h:84 */
struct saml1__DoNotCacheConditionType;	/* saml1.h:87 */
struct saml1__SubjectStatementAbstractType;	/* saml1.h:96 */
struct saml1__NameIdentifierType;	/* saml1.h:102 */
struct saml1__ActionType;	/* saml1.h:120 */
struct saml1__AttributeType;	/* saml1.h:132 */
struct saml1__AuthenticationStatementType;	/* saml1.h:108 */
struct saml1__AuthorizationDecisionStatementType;	/* saml1.h:117 */
struct saml1__AttributeStatementType;	/* saml1.h:126 */
struct saml2__BaseIDAbstractType;	/* saml2.h:75 */
struct saml2__EncryptedElementType;	/* saml2.h:81 */
struct __saml2__union_AssertionType;	/* saml2.h:234 */
struct saml2__AssertionType;	/* saml2.h:84 */
struct saml2__SubjectType;	/* saml2.h:87 */
struct saml2__SubjectConfirmationType;	/* saml2.h:90 */
struct __saml2__union_ConditionsType;	/* saml2.h:327 */
struct saml2__ConditionsType;	/* saml2.h:99 */
struct saml2__ConditionAbstractType;	/* saml2.h:102 */
struct __saml2__union_AdviceType;	/* saml2.h:376 */
struct saml2__AdviceType;	/* saml2.h:114 */
struct saml2__StatementAbstractType;	/* saml2.h:117 */
struct saml2__SubjectLocalityType;	/* saml2.h:123 */
struct saml2__AuthnContextType;	/* saml2.h:126 */
struct __saml2__union_EvidenceType;	/* saml2.h:479 */
struct saml2__EvidenceType;	/* saml2.h:135 */
struct saml2__AttributeType;	/* saml2.h:141 */
struct saml2__NameIDType;	/* saml2.h:78 */
struct saml2__SubjectConfirmationDataType;	/* saml2.h:93 */
struct saml2__AudienceRestrictionType;	/* saml2.h:105 */
struct saml2__OneTimeUseType;	/* saml2.h:108 */
struct saml2__ProxyRestrictionType;	/* saml2.h:111 */
struct saml2__AuthnStatementType;	/* saml2.h:120 */
struct saml2__AuthzDecisionStatementType;	/* saml2.h:129 */
struct saml2__ActionType;	/* saml2.h:132 */
struct __saml2__union_AttributeStatementType;	/* saml2.h:729 */
struct saml2__AttributeStatementType;	/* saml2.h:138 */
struct saml2__KeyInfoConfirmationDataType;	/* saml2.h:96 */
struct _wsse__Security;	/* wsse.h:212 */
struct _wsse__Password;	/* wsse.h:146 */

/* wsa5.h:65 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (12)
/* complex XML schema type 'wsa5:EndpointReferenceType': */
struct SOAP_CMAC wsa5__EndpointReferenceType {
      public:
        /** Required element 'wsa5:Address' of XML schema type 'xsd:string' */
        char *Address;
        /** Optional element 'wsa5:ReferenceParameters' of XML schema type 'wsa5:ReferenceParametersType' */
        struct wsa5__ReferenceParametersType *ReferenceParameters;
        /** Optional element 'wsa5:Metadata' of XML schema type 'wsa5:MetadataType' */
        struct wsa5__MetadataType *Metadata;
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__EndpointReferenceType */
        long soap_type() const { return SOAP_TYPE_wsa5__EndpointReferenceType; }
        /** Constructor with member initializations */
        wsa5__EndpointReferenceType() : Address(), ReferenceParameters(), Metadata(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:68 */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (13)
/* complex XML schema type 'wsa5:ReferenceParametersType': */
struct SOAP_CMAC wsa5__ReferenceParametersType {
      public:
        /** Optional element 'chan:ChannelInstance' of XML schema type 'xsd:int' */
        int *chan__ChannelInstance;
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ReferenceParametersType */
        long soap_type() const { return SOAP_TYPE_wsa5__ReferenceParametersType; }
        /** Constructor with member initializations */
        wsa5__ReferenceParametersType() : chan__ChannelInstance(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:71 */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (14)
/* complex XML schema type 'wsa5:MetadataType': */
struct SOAP_CMAC wsa5__MetadataType {
      public:
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__MetadataType */
        long soap_type() const { return SOAP_TYPE_wsa5__MetadataType; }
        /** Constructor with member initializations */
        wsa5__MetadataType() : __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:86 */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (16)
/* complex XML schema type 'wsa5:ProblemActionType': */
struct SOAP_CMAC wsa5__ProblemActionType {
      public:
        /** Optional element 'wsa5:Action' of XML schema type 'xsd:string' */
        char *Action;
        /** Optional element 'wsa5:SoapAction' of XML schema type 'xsd:string' */
        char *SoapAction;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ProblemActionType */
        long soap_type() const { return SOAP_TYPE_wsa5__ProblemActionType; }
        /** Constructor with member initializations */
        wsa5__ProblemActionType() : Action(), SoapAction(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:74 */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (15)
/* simple XML schema type 'wsa5:RelatesToType': */
struct SOAP_CMAC wsa5__RelatesToType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'RelationshipType' of XML schema type 'wsa5:RelationshipTypeOpenEnum' */
        char *RelationshipType;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__RelatesToType */
        long soap_type() const { return SOAP_TYPE_wsa5__RelatesToType; }
        /** Constructor with member initializations */
        wsa5__RelatesToType() : __item(), RelationshipType(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:260 */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (41)
/* simple XML schema type 'chan:ChannelInstanceType': */
struct SOAP_CMAC chan__ChannelInstanceType {
      public:
        /** Simple content of XML schema type 'xsd:int' wrapped by this struct */
        int __item;
        /** Optional attribute 'wsa5:IsReferenceParameter' of XML schema type 'wsa5:IsReferenceParameter' */
        enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter;	/**< initialized with default value = (enum _wsa5__IsReferenceParameter)0 */
      public:
        /** Return unique type id SOAP_TYPE_chan__ChannelInstanceType */
        long soap_type() const { return SOAP_TYPE_chan__ChannelInstanceType; }
        /** Constructor with member initializations */
        chan__ChannelInstanceType() : __item(), wsa5__IsReferenceParameter((enum _wsa5__IsReferenceParameter)0) { }
        /** Friend allocator */
        friend SOAP_FMAC1 chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:266 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (42)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Optional element 'wsa5:MessageID' of XML schema type 'wsa5:MessageID' */
        char *wsa5__MessageID;
        /** Optional element 'wsa5:RelatesTo' of XML schema type 'wsa5:RelatesTo' */
        struct wsa5__RelatesToType *wsa5__RelatesTo;
        /** Optional element 'wsa5:From' of XML schema type 'wsa5:From' */
        struct wsa5__EndpointReferenceType *wsa5__From;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__ReplyTo;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__FaultTo;
        /** MustUnderstand */
        char *wsa5__To;
        /** MustUnderstand */
        char *wsa5__Action;
        /** Optional element 'chan:ChannelInstance' of XML schema type 'chan:ChannelInstanceType' */
        struct chan__ChannelInstanceType *chan__ChannelInstance;
        /** MustUnderstand */
        struct _wsse__Security *wsse__Security;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : wsa5__MessageID(), wsa5__RelatesTo(), wsa5__From(), wsa5__ReplyTo(), wsa5__FaultTo(), wsa5__To(), wsa5__Action(), chan__ChannelInstance(), wsse__Security() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:284 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (50)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:285 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (52)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:290 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (56)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:217 */
#ifndef SOAP_TYPE_tev__Capabilities
#define SOAP_TYPE_tev__Capabilities (65)
/* complex XML schema type 'tev:Capabilities': */
class SOAP_CMAC tev__Capabilities {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional attribute 'WSSubscriptionPolicySupport' of XML schema type 'xsd:boolean'
        bool *WSSubscriptionPolicySupport;
        /// Optional attribute 'WSPullPointSupport' of XML schema type 'xsd:boolean'
        bool *WSPullPointSupport;
        /// Optional attribute 'WSPausableSubscriptionManagerInterfaceSupport' of XML schema type 'xsd:boolean'
        bool *WSPausableSubscriptionManagerInterfaceSupport;
        /// Optional attribute 'MaxNotificationProducers' of XML schema type 'xsd:int'
        int *MaxNotificationProducers;
        /// Optional attribute 'MaxPullPoints' of XML schema type 'xsd:int'
        int *MaxPullPoints;
        /// Optional attribute 'PersistentNotificationStorage' of XML schema type 'xsd:boolean'
        bool *PersistentNotificationStorage;
        /// Optional attribute 'EventBrokerProtocols' of XML schema type 'xsd:string'
        std::string *EventBrokerProtocols;
        /// Optional attribute 'MaxEventBrokers' of XML schema type 'xsd:int'
        int *MaxEventBrokers;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tev__Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tev__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tev__Capabilities, default initialized and not managed by a soap context
        virtual tev__Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tev__Capabilities); }
      public:
        /// Constructor with default initializations
        tev__Capabilities() : __any(), WSSubscriptionPolicySupport(), WSPullPointSupport(), WSPausableSubscriptionManagerInterfaceSupport(), MaxNotificationProducers(), MaxPullPoints(), PersistentNotificationStorage(), EventBrokerProtocols(), MaxEventBrokers(), __anyAttribute(), soap() { }
        virtual ~tev__Capabilities() { }
        /// Friend allocator used by soap_new_tev__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 tev__Capabilities * SOAP_FMAC2 soap_instantiate_tev__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:219 */
#ifndef SOAP_TYPE_tev__EventBrokerConfig
#define SOAP_TYPE_tev__EventBrokerConfig (66)
/* complex XML schema type 'tev:EventBrokerConfig': */
class SOAP_CMAC tev__EventBrokerConfig {
      public:
        /// Required element 'tev:Address' of XML schema type 'xsd:anyURI'
        std::string Address;
        /// Required element 'tev:TopicPrefix' of XML schema type 'xsd:string'
        std::string TopicPrefix;
        /// Optional element 'tev:UserName' of XML schema type 'xsd:string'
        std::string *UserName;
        /// Optional element 'tev:Password' of XML schema type 'xsd:string'
        std::string *Password;
        /// Optional element 'tev:CertificateID' of XML schema type 'xsd:token'
        std::string *CertificateID;
        /// Optional element 'tev:PublishFilter' of XML schema type 'wsnt:FilterType'
        wsnt__FilterType *PublishFilter;
        /// Optional element 'tev:QoS' of XML schema type 'xsd:int'
        int *QoS;
        /// Optional element 'tev:Status' of XML schema type 'xsd:string'
        std::string *Status;
        /// Optional element 'tev:CertPathValidationPolicyID' of XML schema type 'xsd:string'
        std::string *CertPathValidationPolicyID;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tev__EventBrokerConfig
        virtual long soap_type(void) const { return SOAP_TYPE_tev__EventBrokerConfig; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tev__EventBrokerConfig, default initialized and not managed by a soap context
        virtual tev__EventBrokerConfig *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tev__EventBrokerConfig); }
      public:
        /// Constructor with default initializations
        tev__EventBrokerConfig() : Address(), TopicPrefix(), UserName(), Password(), CertificateID(), PublishFilter(), QoS(), Status(), CertPathValidationPolicyID(), __any(), __anyAttribute(), soap() { }
        virtual ~tev__EventBrokerConfig() { }
        /// Friend allocator used by soap_new_tev__EventBrokerConfig(struct soap*, int)
        friend SOAP_FMAC1 tev__EventBrokerConfig * SOAP_FMAC2 soap_instantiate_tev__EventBrokerConfig(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:221 */
#ifndef SOAP_TYPE__tev__GetServiceCapabilities
#define SOAP_TYPE__tev__GetServiceCapabilities (67)
/* complex XML schema type 'tev:GetServiceCapabilities': */
class SOAP_CMAC _tev__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__GetServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tev__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _tev__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__GetServiceCapabilities); }
      public:
        /// Constructor with default initializations
        _tev__GetServiceCapabilities() : soap() { }
        virtual ~_tev__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__tev__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _tev__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tev__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:223 */
#ifndef SOAP_TYPE__tev__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tev__GetServiceCapabilitiesResponse (68)
/* complex XML schema type 'tev:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _tev__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'tev:Capabilities' of XML schema type 'tev:Capabilities'
        tev__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__GetServiceCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _tev__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with default initializations
        _tev__GetServiceCapabilitiesResponse() : Capabilities(), soap() { }
        virtual ~_tev__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__tev__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tev__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:764 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy
#define SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy (153)
/* complex XML schema type 'tev:CreatePullPointSubscription-SubscriptionPolicy': */
class SOAP_CMAC _tev__CreatePullPointSubscription_SubscriptionPolicy {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__CreatePullPointSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _tev__CreatePullPointSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__CreatePullPointSubscription_SubscriptionPolicy); }
      public:
        /// Constructor with default initializations
        _tev__CreatePullPointSubscription_SubscriptionPolicy() : __any() { }
        virtual ~_tev__CreatePullPointSubscription_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:225 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription
#define SOAP_TYPE__tev__CreatePullPointSubscription (69)
/* complex XML schema type 'tev:CreatePullPointSubscription': */
class SOAP_CMAC _tev__CreatePullPointSubscription {
      public:
        /// Optional element 'tev:Filter' of XML schema type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'tev:InitialTerminationTime' of XML schema type 'wsnt:AbsoluteOrRelativeTimeType'
        std::string *InitialTerminationTime;
        /// Optional element 'tev:SubscriptionPolicy' of XML schema type 'tev:CreatePullPointSubscription-SubscriptionPolicy'
        _tev__CreatePullPointSubscription_SubscriptionPolicy *SubscriptionPolicy;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__CreatePullPointSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__tev__CreatePullPointSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__CreatePullPointSubscription, default initialized and not managed by a soap context
        virtual _tev__CreatePullPointSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__CreatePullPointSubscription); }
      public:
        /// Constructor with default initializations
        _tev__CreatePullPointSubscription() : Filter(), InitialTerminationTime(), SubscriptionPolicy(), __any(), soap() { }
        virtual ~_tev__CreatePullPointSubscription() { }
        /// Friend allocator used by soap_new__tev__CreatePullPointSubscription(struct soap*, int)
        friend SOAP_FMAC1 _tev__CreatePullPointSubscription * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:227 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscriptionResponse
#define SOAP_TYPE__tev__CreatePullPointSubscriptionResponse (70)
/* complex XML schema type 'tev:CreatePullPointSubscriptionResponse': */
class SOAP_CMAC _tev__CreatePullPointSubscriptionResponse {
      public:
        /// Required element 'tev:SubscriptionReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType SubscriptionReference;
        /// Required element 'wsnt:CurrentTime' of XML schema type 'xsd:dateTime'
        time_t wsnt__CurrentTime;
        /// Required element 'wsnt:TerminationTime' of XML schema type 'xsd:dateTime'
        time_t wsnt__TerminationTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__CreatePullPointSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__CreatePullPointSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__CreatePullPointSubscriptionResponse, default initialized and not managed by a soap context
        virtual _tev__CreatePullPointSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__CreatePullPointSubscriptionResponse); }
      public:
        /// Constructor with default initializations
        _tev__CreatePullPointSubscriptionResponse() : SubscriptionReference(), wsnt__CurrentTime(), wsnt__TerminationTime(), __any(), soap() { }
        virtual ~_tev__CreatePullPointSubscriptionResponse() { }
        /// Friend allocator used by soap_new__tev__CreatePullPointSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:229 */
#ifndef SOAP_TYPE__tev__PullMessages
#define SOAP_TYPE__tev__PullMessages (71)
/* complex XML schema type 'tev:PullMessages': */
class SOAP_CMAC _tev__PullMessages {
      public:
        /// Required element 'tev:Timeout' of XML schema type 'xsd:duration'
        std::string Timeout;
        /// Required element 'tev:MessageLimit' of XML schema type 'xsd:int'
        int MessageLimit;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__PullMessages
        virtual long soap_type(void) const { return SOAP_TYPE__tev__PullMessages; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__PullMessages, default initialized and not managed by a soap context
        virtual _tev__PullMessages *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__PullMessages); }
      public:
        /// Constructor with default initializations
        _tev__PullMessages() : Timeout(), MessageLimit(), __any(), soap() { }
        virtual ~_tev__PullMessages() { }
        /// Friend allocator used by soap_new__tev__PullMessages(struct soap*, int)
        friend SOAP_FMAC1 _tev__PullMessages * SOAP_FMAC2 soap_instantiate__tev__PullMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:231 */
#ifndef SOAP_TYPE__tev__PullMessagesResponse
#define SOAP_TYPE__tev__PullMessagesResponse (72)
/* complex XML schema type 'tev:PullMessagesResponse': */
class SOAP_CMAC _tev__PullMessagesResponse {
      public:
        /// Required element 'tev:CurrentTime' of XML schema type 'xsd:dateTime'
        time_t CurrentTime;
        /// Required element 'tev:TerminationTime' of XML schema type 'xsd:dateTime'
        time_t TerminationTime;
        /// Optional element 'wsnt:NotificationMessage' of XML schema type 'wsnt:NotificationMessageHolderType'
        std::vector<wsnt__NotificationMessageHolderType *> wsnt__NotificationMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__PullMessagesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__PullMessagesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__PullMessagesResponse, default initialized and not managed by a soap context
        virtual _tev__PullMessagesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__PullMessagesResponse); }
      public:
        /// Constructor with default initializations
        _tev__PullMessagesResponse() : CurrentTime(), TerminationTime(), wsnt__NotificationMessage(), soap() { }
        virtual ~_tev__PullMessagesResponse() { }
        /// Friend allocator used by soap_new__tev__PullMessagesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__PullMessagesResponse * SOAP_FMAC2 soap_instantiate__tev__PullMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:233 */
#ifndef SOAP_TYPE__tev__PullMessagesFaultResponse
#define SOAP_TYPE__tev__PullMessagesFaultResponse (73)
/* complex XML schema type 'tev:PullMessagesFaultResponse': */
class SOAP_CMAC _tev__PullMessagesFaultResponse {
      public:
        /// Required element 'tev:MaxTimeout' of XML schema type 'xsd:duration'
        std::string MaxTimeout;
        /// Required element 'tev:MaxMessageLimit' of XML schema type 'xsd:int'
        int MaxMessageLimit;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__PullMessagesFaultResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__PullMessagesFaultResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__PullMessagesFaultResponse, default initialized and not managed by a soap context
        virtual _tev__PullMessagesFaultResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__PullMessagesFaultResponse); }
      public:
        /// Constructor with default initializations
        _tev__PullMessagesFaultResponse() : MaxTimeout(), MaxMessageLimit(), __any(), soap() { }
        virtual ~_tev__PullMessagesFaultResponse() { }
        /// Friend allocator used by soap_new__tev__PullMessagesFaultResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__PullMessagesFaultResponse * SOAP_FMAC2 soap_instantiate__tev__PullMessagesFaultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:235 */
#ifndef SOAP_TYPE__tev__Seek
#define SOAP_TYPE__tev__Seek (74)
/* complex XML schema type 'tev:Seek': */
class SOAP_CMAC _tev__Seek {
      public:
        /// Required element 'tev:UtcTime' of XML schema type 'xsd:dateTime'
        time_t UtcTime;
        /// Optional element 'tev:Reverse' of XML schema type 'xsd:boolean'
        bool *Reverse;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__Seek
        virtual long soap_type(void) const { return SOAP_TYPE__tev__Seek; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__Seek, default initialized and not managed by a soap context
        virtual _tev__Seek *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__Seek); }
      public:
        /// Constructor with default initializations
        _tev__Seek() : UtcTime(), Reverse(), __any(), soap() { }
        virtual ~_tev__Seek() { }
        /// Friend allocator used by soap_new__tev__Seek(struct soap*, int)
        friend SOAP_FMAC1 _tev__Seek * SOAP_FMAC2 soap_instantiate__tev__Seek(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:237 */
#ifndef SOAP_TYPE__tev__SeekResponse
#define SOAP_TYPE__tev__SeekResponse (75)
/* complex XML schema type 'tev:SeekResponse': */
class SOAP_CMAC _tev__SeekResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__SeekResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__SeekResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__SeekResponse, default initialized and not managed by a soap context
        virtual _tev__SeekResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__SeekResponse); }
      public:
        /// Constructor with default initializations
        _tev__SeekResponse() : soap() { }
        virtual ~_tev__SeekResponse() { }
        /// Friend allocator used by soap_new__tev__SeekResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__SeekResponse * SOAP_FMAC2 soap_instantiate__tev__SeekResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:239 */
#ifndef SOAP_TYPE__tev__SetSynchronizationPoint
#define SOAP_TYPE__tev__SetSynchronizationPoint (76)
/* complex XML schema type 'tev:SetSynchronizationPoint': */
class SOAP_CMAC _tev__SetSynchronizationPoint {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__SetSynchronizationPoint
        virtual long soap_type(void) const { return SOAP_TYPE__tev__SetSynchronizationPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__SetSynchronizationPoint, default initialized and not managed by a soap context
        virtual _tev__SetSynchronizationPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__SetSynchronizationPoint); }
      public:
        /// Constructor with default initializations
        _tev__SetSynchronizationPoint() : soap() { }
        virtual ~_tev__SetSynchronizationPoint() { }
        /// Friend allocator used by soap_new__tev__SetSynchronizationPoint(struct soap*, int)
        friend SOAP_FMAC1 _tev__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate__tev__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:241 */
#ifndef SOAP_TYPE__tev__SetSynchronizationPointResponse
#define SOAP_TYPE__tev__SetSynchronizationPointResponse (77)
/* complex XML schema type 'tev:SetSynchronizationPointResponse': */
class SOAP_CMAC _tev__SetSynchronizationPointResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__SetSynchronizationPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__SetSynchronizationPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__SetSynchronizationPointResponse, default initialized and not managed by a soap context
        virtual _tev__SetSynchronizationPointResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__SetSynchronizationPointResponse); }
      public:
        /// Constructor with default initializations
        _tev__SetSynchronizationPointResponse() : soap() { }
        virtual ~_tev__SetSynchronizationPointResponse() { }
        /// Friend allocator used by soap_new__tev__SetSynchronizationPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__SetSynchronizationPointResponse * SOAP_FMAC2 soap_instantiate__tev__SetSynchronizationPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:243 */
#ifndef SOAP_TYPE__tev__GetEventProperties
#define SOAP_TYPE__tev__GetEventProperties (78)
/* complex XML schema type 'tev:GetEventProperties': */
class SOAP_CMAC _tev__GetEventProperties {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__GetEventProperties
        virtual long soap_type(void) const { return SOAP_TYPE__tev__GetEventProperties; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__GetEventProperties, default initialized and not managed by a soap context
        virtual _tev__GetEventProperties *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__GetEventProperties); }
      public:
        /// Constructor with default initializations
        _tev__GetEventProperties() : soap() { }
        virtual ~_tev__GetEventProperties() { }
        /// Friend allocator used by soap_new__tev__GetEventProperties(struct soap*, int)
        friend SOAP_FMAC1 _tev__GetEventProperties * SOAP_FMAC2 soap_instantiate__tev__GetEventProperties(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:245 */
#ifndef SOAP_TYPE__tev__GetEventPropertiesResponse
#define SOAP_TYPE__tev__GetEventPropertiesResponse (79)
/* complex XML schema type 'tev:GetEventPropertiesResponse': */
class SOAP_CMAC _tev__GetEventPropertiesResponse {
      public:
        /// Required element 'tev:TopicNamespaceLocation' of XML schema type 'xsd:anyURI'
        std::vector<std::string> TopicNamespaceLocation;
        /// Required element 'wsnt:FixedTopicSet' of XML schema type 'xsd:boolean'
        bool wsnt__FixedTopicSet;	///< initialized with default value = (bool)1
        /// Required element 'wstop:TopicSet' of XML schema type 'wstop:TopicSetType'
        wstop__TopicSetType *wstop__TopicSet;
        /// Required element 'wsnt:TopicExpressionDialect' of XML schema type 'xsd:anyURI'
        std::vector<std::string> wsnt__TopicExpressionDialect;
        /// Required element 'tev:MessageContentFilterDialect' of XML schema type 'xsd:anyURI'
        std::vector<std::string> MessageContentFilterDialect;
        /// Optional element 'tev:ProducerPropertiesFilterDialect' of XML schema type 'xsd:anyURI'
        std::vector<std::string> ProducerPropertiesFilterDialect;
        /// Required element 'tev:MessageContentSchemaLocation' of XML schema type 'xsd:anyURI'
        std::vector<std::string> MessageContentSchemaLocation;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__GetEventPropertiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__GetEventPropertiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__GetEventPropertiesResponse, default initialized and not managed by a soap context
        virtual _tev__GetEventPropertiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__GetEventPropertiesResponse); }
      public:
        /// Constructor with default initializations
        _tev__GetEventPropertiesResponse() : TopicNamespaceLocation(), wsnt__FixedTopicSet((bool)1), wstop__TopicSet(), wsnt__TopicExpressionDialect(), MessageContentFilterDialect(), ProducerPropertiesFilterDialect(), MessageContentSchemaLocation(), __any(), soap() { }
        virtual ~_tev__GetEventPropertiesResponse() { }
        /// Friend allocator used by soap_new__tev__GetEventPropertiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__GetEventPropertiesResponse * SOAP_FMAC2 soap_instantiate__tev__GetEventPropertiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:250 */
#ifndef SOAP_TYPE__tev__AddEventBroker
#define SOAP_TYPE__tev__AddEventBroker (80)
/* complex XML schema type 'tev:AddEventBroker': */
class SOAP_CMAC _tev__AddEventBroker {
      public:
        /// Required element 'tev:EventBroker' of XML schema type 'tev:EventBrokerConfig'
        tev__EventBrokerConfig *EventBroker;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__AddEventBroker
        virtual long soap_type(void) const { return SOAP_TYPE__tev__AddEventBroker; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__AddEventBroker, default initialized and not managed by a soap context
        virtual _tev__AddEventBroker *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__AddEventBroker); }
      public:
        /// Constructor with default initializations
        _tev__AddEventBroker() : EventBroker(), soap() { }
        virtual ~_tev__AddEventBroker() { }
        /// Friend allocator used by soap_new__tev__AddEventBroker(struct soap*, int)
        friend SOAP_FMAC1 _tev__AddEventBroker * SOAP_FMAC2 soap_instantiate__tev__AddEventBroker(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:252 */
#ifndef SOAP_TYPE__tev__AddEventBrokerResponse
#define SOAP_TYPE__tev__AddEventBrokerResponse (81)
/* complex XML schema type 'tev:AddEventBrokerResponse': */
class SOAP_CMAC _tev__AddEventBrokerResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__AddEventBrokerResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__AddEventBrokerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__AddEventBrokerResponse, default initialized and not managed by a soap context
        virtual _tev__AddEventBrokerResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__AddEventBrokerResponse); }
      public:
        /// Constructor with default initializations
        _tev__AddEventBrokerResponse() : soap() { }
        virtual ~_tev__AddEventBrokerResponse() { }
        /// Friend allocator used by soap_new__tev__AddEventBrokerResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__AddEventBrokerResponse * SOAP_FMAC2 soap_instantiate__tev__AddEventBrokerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:254 */
#ifndef SOAP_TYPE__tev__DeleteEventBroker
#define SOAP_TYPE__tev__DeleteEventBroker (82)
/* complex XML schema type 'tev:DeleteEventBroker': */
class SOAP_CMAC _tev__DeleteEventBroker {
      public:
        /// Required element 'tev:Address' of XML schema type 'xsd:anyURI'
        std::string Address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__DeleteEventBroker
        virtual long soap_type(void) const { return SOAP_TYPE__tev__DeleteEventBroker; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__DeleteEventBroker, default initialized and not managed by a soap context
        virtual _tev__DeleteEventBroker *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__DeleteEventBroker); }
      public:
        /// Constructor with default initializations
        _tev__DeleteEventBroker() : Address(), soap() { }
        virtual ~_tev__DeleteEventBroker() { }
        /// Friend allocator used by soap_new__tev__DeleteEventBroker(struct soap*, int)
        friend SOAP_FMAC1 _tev__DeleteEventBroker * SOAP_FMAC2 soap_instantiate__tev__DeleteEventBroker(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:256 */
#ifndef SOAP_TYPE__tev__DeleteEventBrokerResponse
#define SOAP_TYPE__tev__DeleteEventBrokerResponse (83)
/* complex XML schema type 'tev:DeleteEventBrokerResponse': */
class SOAP_CMAC _tev__DeleteEventBrokerResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__DeleteEventBrokerResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__DeleteEventBrokerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__DeleteEventBrokerResponse, default initialized and not managed by a soap context
        virtual _tev__DeleteEventBrokerResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__DeleteEventBrokerResponse); }
      public:
        /// Constructor with default initializations
        _tev__DeleteEventBrokerResponse() : soap() { }
        virtual ~_tev__DeleteEventBrokerResponse() { }
        /// Friend allocator used by soap_new__tev__DeleteEventBrokerResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__DeleteEventBrokerResponse * SOAP_FMAC2 soap_instantiate__tev__DeleteEventBrokerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:258 */
#ifndef SOAP_TYPE__tev__GetEventBrokers
#define SOAP_TYPE__tev__GetEventBrokers (84)
/* complex XML schema type 'tev:GetEventBrokers': */
class SOAP_CMAC _tev__GetEventBrokers {
      public:
        /// Optional element 'tev:Address' of XML schema type 'xsd:anyURI'
        std::string *Address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__GetEventBrokers
        virtual long soap_type(void) const { return SOAP_TYPE__tev__GetEventBrokers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__GetEventBrokers, default initialized and not managed by a soap context
        virtual _tev__GetEventBrokers *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__GetEventBrokers); }
      public:
        /// Constructor with default initializations
        _tev__GetEventBrokers() : Address(), soap() { }
        virtual ~_tev__GetEventBrokers() { }
        /// Friend allocator used by soap_new__tev__GetEventBrokers(struct soap*, int)
        friend SOAP_FMAC1 _tev__GetEventBrokers * SOAP_FMAC2 soap_instantiate__tev__GetEventBrokers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:260 */
#ifndef SOAP_TYPE__tev__GetEventBrokersResponse
#define SOAP_TYPE__tev__GetEventBrokersResponse (85)
/* complex XML schema type 'tev:GetEventBrokersResponse': */
class SOAP_CMAC _tev__GetEventBrokersResponse {
      public:
        /// Optional element 'tev:EventBroker' of XML schema type 'tev:EventBrokerConfig'
        std::vector<tev__EventBrokerConfig *> EventBroker;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__GetEventBrokersResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__GetEventBrokersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__GetEventBrokersResponse, default initialized and not managed by a soap context
        virtual _tev__GetEventBrokersResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__GetEventBrokersResponse); }
      public:
        /// Constructor with default initializations
        _tev__GetEventBrokersResponse() : EventBroker(), soap() { }
        virtual ~_tev__GetEventBrokersResponse() { }
        /// Friend allocator used by soap_new__tev__GetEventBrokersResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__GetEventBrokersResponse * SOAP_FMAC2 soap_instantiate__tev__GetEventBrokersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:1375 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (164)
/* complex XML schema type 'wsrfbf:BaseFaultType-ErrorCode': */
class SOAP_CMAC _wsrfbf__BaseFaultType_ErrorCode {
      public:
        /// Required attribute 'dialect' of XML schema type 'xsd:anyURI'
        std::string dialect;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_ErrorCode, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_ErrorCode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_ErrorCode); }
      public:
        /// Constructor with default initializations
        _wsrfbf__BaseFaultType_ErrorCode() : dialect(), __mixed() { }
        virtual ~_wsrfbf__BaseFaultType_ErrorCode() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:1398 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (166)
/* simple XML schema type 'wsrfbf:BaseFaultType-Description': */
class SOAP_CMAC _wsrfbf__BaseFaultType_Description {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'xml:lang' of XML schema type 'xml:lang'
        std::string *xml__lang;
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_Description
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_Description; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_Description, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_Description *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_Description); }
      public:
        /// Constructor with default initializations
        _wsrfbf__BaseFaultType_Description() : __item(), xml__lang() { }
        virtual ~_wsrfbf__BaseFaultType_Description() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_Description(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_Description * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:1416 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (169)
/* complex XML schema type 'wsrfbf:BaseFaultType-FaultCause': */
class SOAP_CMAC _wsrfbf__BaseFaultType_FaultCause {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_FaultCause, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_FaultCause *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_FaultCause); }
      public:
        /// Constructor with default initializations
        _wsrfbf__BaseFaultType_FaultCause() : __any() { }
        virtual ~_wsrfbf__BaseFaultType_FaultCause() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_FaultCause(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:266 */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (88)
/* complex XML schema type 'wsrfbf:BaseFaultType': */
class SOAP_CMAC wsrfbf__BaseFaultType {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Required element 'wsrfbf:Timestamp' of XML schema type 'xsd:dateTime'
        time_t Timestamp;
        /// Optional element 'wsrfbf:Originator' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *Originator;
        /// Optional element 'wsrfbf:ErrorCode' of XML schema type 'wsrfbf:BaseFaultType-ErrorCode'
        _wsrfbf__BaseFaultType_ErrorCode *ErrorCode;
        /// Optional element 'wsrfbf:Description' of XML schema type 'wsrfbf:BaseFaultType-Description'
        std::vector<_wsrfbf__BaseFaultType_Description> Description;
        /// Optional element 'wsrfbf:FaultCause' of XML schema type 'wsrfbf:BaseFaultType-FaultCause'
        _wsrfbf__BaseFaultType_FaultCause *FaultCause;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsrfbf__BaseFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsrfbf__BaseFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrfbf__BaseFaultType, default initialized and not managed by a soap context
        virtual wsrfbf__BaseFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrfbf__BaseFaultType); }
      public:
        /// Constructor with default initializations
        wsrfbf__BaseFaultType() : __any(), Timestamp(), Originator(), ErrorCode(), Description(), FaultCause(), __anyAttribute(), soap() { }
        virtual ~wsrfbf__BaseFaultType() { }
        /// Friend allocator used by soap_new_wsrfbf__BaseFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 soap_instantiate_wsrfbf__BaseFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:268 */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (89)
/* complex XML schema type 'wsnt:QueryExpressionType': */
class SOAP_CMAC wsnt__QueryExpressionType {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
        /// Required attribute 'Dialect' of XML schema type 'xsd:anyURI'
        std::string Dialect;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__QueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__QueryExpressionType, default initialized and not managed by a soap context
        virtual wsnt__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__QueryExpressionType); }
      public:
        /// Constructor with default initializations
        wsnt__QueryExpressionType() : __any(), Dialect(), __mixed(), soap() { }
        virtual ~wsnt__QueryExpressionType() { }
        /// Friend allocator used by soap_new_wsnt__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:270 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (90)
/* complex XML schema type 'wsnt:TopicExpressionType': */
class SOAP_CMAC wsnt__TopicExpressionType {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
        /// Required attribute 'Dialect' of XML schema type 'xsd:anyURI'
        std::string Dialect;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicExpressionType, default initialized and not managed by a soap context
        virtual wsnt__TopicExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicExpressionType); }
      public:
        /// Constructor with default initializations
        wsnt__TopicExpressionType() : __any(), Dialect(), __anyAttribute(), __mixed(), soap() { }
        virtual ~wsnt__TopicExpressionType() { }
        /// Friend allocator used by soap_new_wsnt__TopicExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:272 */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (91)
/* complex XML schema type 'wsnt:FilterType': */
class SOAP_CMAC wsnt__FilterType {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__FilterType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__FilterType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__FilterType, default initialized and not managed by a soap context
        virtual wsnt__FilterType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__FilterType); }
      public:
        /// Constructor with default initializations
        wsnt__FilterType() : __any(), soap() { }
        virtual ~wsnt__FilterType() { }
        /// Friend allocator used by soap_new_wsnt__FilterType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__FilterType * SOAP_FMAC2 soap_instantiate_wsnt__FilterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:274 */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (92)
/* complex XML schema type 'wsnt:SubscriptionPolicyType': */
class SOAP_CMAC wsnt__SubscriptionPolicyType {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__SubscriptionPolicyType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__SubscriptionPolicyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__SubscriptionPolicyType, default initialized and not managed by a soap context
        virtual wsnt__SubscriptionPolicyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__SubscriptionPolicyType); }
      public:
        /// Constructor with default initializations
        wsnt__SubscriptionPolicyType() : __any(), soap() { }
        virtual ~wsnt__SubscriptionPolicyType() { }
        /// Friend allocator used by soap_new_wsnt__SubscriptionPolicyType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_wsnt__SubscriptionPolicyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:1602 */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (172)
/* complex XML schema type 'wsnt:NotificationMessageHolderType-Message': */
class SOAP_CMAC _wsnt__NotificationMessageHolderType_Message {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__NotificationMessageHolderType_Message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__NotificationMessageHolderType_Message, default initialized and not managed by a soap context
        virtual _wsnt__NotificationMessageHolderType_Message *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__NotificationMessageHolderType_Message); }
      public:
        /// Constructor with default initializations
        _wsnt__NotificationMessageHolderType_Message() : __any() { }
        virtual ~_wsnt__NotificationMessageHolderType_Message() { }
        /// Friend allocator used by soap_new__wsnt__NotificationMessageHolderType_Message(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC2 soap_instantiate__wsnt__NotificationMessageHolderType_Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:276 */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (93)
/* complex XML schema type 'wsnt:NotificationMessageHolderType': */
class SOAP_CMAC wsnt__NotificationMessageHolderType {
      public:
        /// Optional element 'wsnt:SubscriptionReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *SubscriptionReference;
        /// Optional element 'wsnt:Topic' of XML schema type 'wsnt:TopicExpressionType'
        wsnt__TopicExpressionType *Topic;
        /// Optional element 'wsnt:ProducerReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *ProducerReference;
        /// Required element 'wsnt:Message' of XML schema type 'wsnt:NotificationMessageHolderType-Message'
        _wsnt__NotificationMessageHolderType_Message Message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NotificationMessageHolderType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NotificationMessageHolderType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NotificationMessageHolderType, default initialized and not managed by a soap context
        virtual wsnt__NotificationMessageHolderType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NotificationMessageHolderType); }
      public:
        /// Constructor with default initializations
        wsnt__NotificationMessageHolderType() : SubscriptionReference(), Topic(), ProducerReference(), Message(), soap() { }
        virtual ~wsnt__NotificationMessageHolderType() { }
        /// Friend allocator used by soap_new_wsnt__NotificationMessageHolderType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_wsnt__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:318 */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (114)
/* complex XML schema type 'wsnt:NotificationProducerRP': */
class SOAP_CMAC _wsnt__NotificationProducerRP {
      public:
        /// Optional element 'wsnt:TopicExpression' of XML schema type 'wsnt:TopicExpressionType'
        std::vector<wsnt__TopicExpressionType *> TopicExpression;
        /// Optional element 'wsnt:FixedTopicSet' of XML schema type 'xsd:boolean'
        bool *FixedTopicSet;	///< optional with default value = (bool)1
        /// Optional element 'wsnt:TopicExpressionDialect' of XML schema type 'xsd:anyURI'
        std::vector<std::string> TopicExpressionDialect;
        /// Optional element 'wstop:TopicSet' of XML schema type 'wstop:TopicSetType'
        wstop__TopicSetType *wstop__TopicSet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__NotificationProducerRP
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__NotificationProducerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__NotificationProducerRP, default initialized and not managed by a soap context
        virtual _wsnt__NotificationProducerRP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__NotificationProducerRP); }
      public:
        /// Constructor with default initializations
        _wsnt__NotificationProducerRP() : TopicExpression(), FixedTopicSet(), TopicExpressionDialect(), wstop__TopicSet(), soap() { }
        virtual ~_wsnt__NotificationProducerRP() { }
        /// Friend allocator used by soap_new__wsnt__NotificationProducerRP(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__wsnt__NotificationProducerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:320 */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (115)
/* complex XML schema type 'wsnt:SubscriptionManagerRP': */
class SOAP_CMAC _wsnt__SubscriptionManagerRP {
      public:
        /// Required element 'wsnt:ConsumerReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType ConsumerReference;
        /// Optional element 'wsnt:Filter' of XML schema type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'wsnt:SubscriptionPolicy' of XML schema type 'wsnt:SubscriptionPolicyType'
        wsnt__SubscriptionPolicyType *SubscriptionPolicy;
        /// Optional element 'wsnt:CreationTime' of XML schema type 'xsd:dateTime'
        time_t *CreationTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__SubscriptionManagerRP
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__SubscriptionManagerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__SubscriptionManagerRP, default initialized and not managed by a soap context
        virtual _wsnt__SubscriptionManagerRP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__SubscriptionManagerRP); }
      public:
        /// Constructor with default initializations
        _wsnt__SubscriptionManagerRP() : ConsumerReference(), Filter(), SubscriptionPolicy(), CreationTime(), soap() { }
        virtual ~_wsnt__SubscriptionManagerRP() { }
        /// Friend allocator used by soap_new__wsnt__SubscriptionManagerRP(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__wsnt__SubscriptionManagerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:322 */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (116)
/* complex XML schema type 'wsnt:Notify': */
class SOAP_CMAC _wsnt__Notify {
      public:
        /// Required element 'wsnt:NotificationMessage' of XML schema type 'wsnt:NotificationMessageHolderType'
        std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Notify
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Notify; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Notify, default initialized and not managed by a soap context
        virtual _wsnt__Notify *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Notify); }
      public:
        /// Constructor with default initializations
        _wsnt__Notify() : NotificationMessage(), __any(), soap() { }
        virtual ~_wsnt__Notify() { }
        /// Friend allocator used by soap_new__wsnt__Notify(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Notify * SOAP_FMAC2 soap_instantiate__wsnt__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:324 */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (117)
/* complex XML schema type 'wsnt:UseRaw': */
class SOAP_CMAC _wsnt__UseRaw {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__UseRaw
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__UseRaw; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__UseRaw, default initialized and not managed by a soap context
        virtual _wsnt__UseRaw *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__UseRaw); }
      public:
        /// Constructor with default initializations
        _wsnt__UseRaw() : soap() { }
        virtual ~_wsnt__UseRaw() { }
        /// Friend allocator used by soap_new__wsnt__UseRaw(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__UseRaw * SOAP_FMAC2 soap_instantiate__wsnt__UseRaw(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:1755 */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (176)
/* complex XML schema type 'wsnt:Subscribe-SubscriptionPolicy': */
class SOAP_CMAC _wsnt__Subscribe_SubscriptionPolicy {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Subscribe_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _wsnt__Subscribe_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Subscribe_SubscriptionPolicy); }
      public:
        /// Constructor with default initializations
        _wsnt__Subscribe_SubscriptionPolicy() : __any() { }
        virtual ~_wsnt__Subscribe_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:326 */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (118)
/* complex XML schema type 'wsnt:Subscribe': */
class SOAP_CMAC _wsnt__Subscribe {
      public:
        /// Required element 'wsnt:ConsumerReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType ConsumerReference;
        /// Optional element 'wsnt:Filter' of XML schema type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'wsnt:InitialTerminationTime' of XML schema type 'wsnt:AbsoluteOrRelativeTimeType'
        std::string *InitialTerminationTime;
        /// Optional element 'wsnt:SubscriptionPolicy' of XML schema type 'wsnt:Subscribe-SubscriptionPolicy'
        _wsnt__Subscribe_SubscriptionPolicy *SubscriptionPolicy;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Subscribe
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Subscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Subscribe, default initialized and not managed by a soap context
        virtual _wsnt__Subscribe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Subscribe); }
      public:
        /// Constructor with default initializations
        _wsnt__Subscribe() : ConsumerReference(), Filter(), InitialTerminationTime(), SubscriptionPolicy(), __any(), soap() { }
        virtual ~_wsnt__Subscribe() { }
        /// Friend allocator used by soap_new__wsnt__Subscribe(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Subscribe * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:328 */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (119)
/* complex XML schema type 'wsnt:SubscribeResponse': */
class SOAP_CMAC _wsnt__SubscribeResponse {
      public:
        /// Required element 'wsnt:SubscriptionReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType SubscriptionReference;
        /// Optional element 'wsnt:CurrentTime' of XML schema type 'xsd:dateTime'
        time_t *CurrentTime;
        /// Optional element 'wsnt:TerminationTime' of XML schema type 'xsd:dateTime'
        time_t *TerminationTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__SubscribeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__SubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__SubscribeResponse, default initialized and not managed by a soap context
        virtual _wsnt__SubscribeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__SubscribeResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__SubscribeResponse() : SubscriptionReference(), CurrentTime(), TerminationTime(), __any(), soap() { }
        virtual ~_wsnt__SubscribeResponse() { }
        /// Friend allocator used by soap_new__wsnt__SubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__SubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__SubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:330 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (120)
/* complex XML schema type 'wsnt:GetCurrentMessage': */
class SOAP_CMAC _wsnt__GetCurrentMessage {
      public:
        /// Required element 'wsnt:Topic' of XML schema type 'wsnt:TopicExpressionType'
        wsnt__TopicExpressionType *Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetCurrentMessage
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetCurrentMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetCurrentMessage, default initialized and not managed by a soap context
        virtual _wsnt__GetCurrentMessage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetCurrentMessage); }
      public:
        /// Constructor with default initializations
        _wsnt__GetCurrentMessage() : Topic(), __any(), soap() { }
        virtual ~_wsnt__GetCurrentMessage() { }
        /// Friend allocator used by soap_new__wsnt__GetCurrentMessage(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:332 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (121)
/* complex XML schema type 'wsnt:GetCurrentMessageResponse': */
class SOAP_CMAC _wsnt__GetCurrentMessageResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetCurrentMessageResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetCurrentMessageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetCurrentMessageResponse, default initialized and not managed by a soap context
        virtual _wsnt__GetCurrentMessageResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetCurrentMessageResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__GetCurrentMessageResponse() : __any(), soap() { }
        virtual ~_wsnt__GetCurrentMessageResponse() { }
        /// Friend allocator used by soap_new__wsnt__GetCurrentMessageResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:334 */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (122)
/* complex XML schema type 'wsnt:GetMessages': */
class SOAP_CMAC _wsnt__GetMessages {
      public:
        /// Optional element 'wsnt:MaximumNumber' of XML schema type 'xsd:nonNegativeInteger'
        std::string *MaximumNumber;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetMessages
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetMessages; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetMessages, default initialized and not managed by a soap context
        virtual _wsnt__GetMessages *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetMessages); }
      public:
        /// Constructor with default initializations
        _wsnt__GetMessages() : MaximumNumber(), __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__GetMessages() { }
        /// Friend allocator used by soap_new__wsnt__GetMessages(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetMessages * SOAP_FMAC2 soap_instantiate__wsnt__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:336 */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (123)
/* complex XML schema type 'wsnt:GetMessagesResponse': */
class SOAP_CMAC _wsnt__GetMessagesResponse {
      public:
        /// Optional element 'wsnt:NotificationMessage' of XML schema type 'wsnt:NotificationMessageHolderType'
        std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetMessagesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetMessagesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetMessagesResponse, default initialized and not managed by a soap context
        virtual _wsnt__GetMessagesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetMessagesResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__GetMessagesResponse() : NotificationMessage(), __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__GetMessagesResponse() { }
        /// Friend allocator used by soap_new__wsnt__GetMessagesResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:338 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (124)
/* complex XML schema type 'wsnt:DestroyPullPoint': */
class SOAP_CMAC _wsnt__DestroyPullPoint {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__DestroyPullPoint
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__DestroyPullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__DestroyPullPoint, default initialized and not managed by a soap context
        virtual _wsnt__DestroyPullPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__DestroyPullPoint); }
      public:
        /// Constructor with default initializations
        _wsnt__DestroyPullPoint() : __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__DestroyPullPoint() { }
        /// Friend allocator used by soap_new__wsnt__DestroyPullPoint(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:340 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (125)
/* complex XML schema type 'wsnt:DestroyPullPointResponse': */
class SOAP_CMAC _wsnt__DestroyPullPointResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__DestroyPullPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__DestroyPullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__DestroyPullPointResponse, default initialized and not managed by a soap context
        virtual _wsnt__DestroyPullPointResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__DestroyPullPointResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__DestroyPullPointResponse() : __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__DestroyPullPointResponse() { }
        /// Friend allocator used by soap_new__wsnt__DestroyPullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:342 */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (126)
/* complex XML schema type 'wsnt:CreatePullPoint': */
class SOAP_CMAC _wsnt__CreatePullPoint {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__CreatePullPoint
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__CreatePullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__CreatePullPoint, default initialized and not managed by a soap context
        virtual _wsnt__CreatePullPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__CreatePullPoint); }
      public:
        /// Constructor with default initializations
        _wsnt__CreatePullPoint() : __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__CreatePullPoint() { }
        /// Friend allocator used by soap_new__wsnt__CreatePullPoint(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__CreatePullPoint * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:344 */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (127)
/* complex XML schema type 'wsnt:CreatePullPointResponse': */
class SOAP_CMAC _wsnt__CreatePullPointResponse {
      public:
        /// Required element 'wsnt:PullPoint' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType PullPoint;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__CreatePullPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__CreatePullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__CreatePullPointResponse, default initialized and not managed by a soap context
        virtual _wsnt__CreatePullPointResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__CreatePullPointResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__CreatePullPointResponse() : PullPoint(), __any(), __anyAttribute(), soap() { }
        virtual ~_wsnt__CreatePullPointResponse() { }
        /// Friend allocator used by soap_new__wsnt__CreatePullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:346 */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (128)
/* complex XML schema type 'wsnt:Renew': */
class SOAP_CMAC _wsnt__Renew {
      public:
        /// Required nillable (xsi:nil when NULL) element 'wsnt:TerminationTime' of XML schema type 'wsnt:AbsoluteOrRelativeTimeType'
        std::string *TerminationTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Renew
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Renew; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Renew, default initialized and not managed by a soap context
        virtual _wsnt__Renew *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Renew); }
      public:
        /// Constructor with default initializations
        _wsnt__Renew() : TerminationTime(), __any(), soap() { }
        virtual ~_wsnt__Renew() { }
        /// Friend allocator used by soap_new__wsnt__Renew(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Renew * SOAP_FMAC2 soap_instantiate__wsnt__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:348 */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (129)
/* complex XML schema type 'wsnt:RenewResponse': */
class SOAP_CMAC _wsnt__RenewResponse {
      public:
        /// Required element 'wsnt:TerminationTime' of XML schema type 'xsd:dateTime'
        time_t TerminationTime;
        /// Optional element 'wsnt:CurrentTime' of XML schema type 'xsd:dateTime'
        time_t *CurrentTime;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__RenewResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__RenewResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__RenewResponse, default initialized and not managed by a soap context
        virtual _wsnt__RenewResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__RenewResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__RenewResponse() : TerminationTime(), CurrentTime(), __any(), soap() { }
        virtual ~_wsnt__RenewResponse() { }
        /// Friend allocator used by soap_new__wsnt__RenewResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__RenewResponse * SOAP_FMAC2 soap_instantiate__wsnt__RenewResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:350 */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (130)
/* complex XML schema type 'wsnt:Unsubscribe': */
class SOAP_CMAC _wsnt__Unsubscribe {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Unsubscribe
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Unsubscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Unsubscribe, default initialized and not managed by a soap context
        virtual _wsnt__Unsubscribe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Unsubscribe); }
      public:
        /// Constructor with default initializations
        _wsnt__Unsubscribe() : __any(), soap() { }
        virtual ~_wsnt__Unsubscribe() { }
        /// Friend allocator used by soap_new__wsnt__Unsubscribe(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Unsubscribe * SOAP_FMAC2 soap_instantiate__wsnt__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:352 */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (131)
/* complex XML schema type 'wsnt:UnsubscribeResponse': */
class SOAP_CMAC _wsnt__UnsubscribeResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__UnsubscribeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__UnsubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__UnsubscribeResponse, default initialized and not managed by a soap context
        virtual _wsnt__UnsubscribeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__UnsubscribeResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__UnsubscribeResponse() : __any(), soap() { }
        virtual ~_wsnt__UnsubscribeResponse() { }
        /// Friend allocator used by soap_new__wsnt__UnsubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__UnsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:354 */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (132)
/* complex XML schema type 'wsnt:PauseSubscription': */
class SOAP_CMAC _wsnt__PauseSubscription {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__PauseSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__PauseSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__PauseSubscription, default initialized and not managed by a soap context
        virtual _wsnt__PauseSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__PauseSubscription); }
      public:
        /// Constructor with default initializations
        _wsnt__PauseSubscription() : __any(), soap() { }
        virtual ~_wsnt__PauseSubscription() { }
        /// Friend allocator used by soap_new__wsnt__PauseSubscription(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__PauseSubscription * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:356 */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (133)
/* complex XML schema type 'wsnt:PauseSubscriptionResponse': */
class SOAP_CMAC _wsnt__PauseSubscriptionResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__PauseSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__PauseSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__PauseSubscriptionResponse, default initialized and not managed by a soap context
        virtual _wsnt__PauseSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__PauseSubscriptionResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__PauseSubscriptionResponse() : __any(), soap() { }
        virtual ~_wsnt__PauseSubscriptionResponse() { }
        /// Friend allocator used by soap_new__wsnt__PauseSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:358 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (134)
/* complex XML schema type 'wsnt:ResumeSubscription': */
class SOAP_CMAC _wsnt__ResumeSubscription {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__ResumeSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__ResumeSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__ResumeSubscription, default initialized and not managed by a soap context
        virtual _wsnt__ResumeSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__ResumeSubscription); }
      public:
        /// Constructor with default initializations
        _wsnt__ResumeSubscription() : __any(), soap() { }
        virtual ~_wsnt__ResumeSubscription() { }
        /// Friend allocator used by soap_new__wsnt__ResumeSubscription(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__ResumeSubscription * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:360 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (135)
/* complex XML schema type 'wsnt:ResumeSubscriptionResponse': */
class SOAP_CMAC _wsnt__ResumeSubscriptionResponse {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__ResumeSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__ResumeSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__ResumeSubscriptionResponse, default initialized and not managed by a soap context
        virtual _wsnt__ResumeSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__ResumeSubscriptionResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__ResumeSubscriptionResponse() : __any(), soap() { }
        virtual ~_wsnt__ResumeSubscriptionResponse() { }
        /// Friend allocator used by soap_new__wsnt__ResumeSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:362 */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (136)
/* complex XML schema type 'wstop:Documentation': */
class SOAP_CMAC wstop__Documentation {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wstop__Documentation
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__Documentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__Documentation, default initialized and not managed by a soap context
        virtual wstop__Documentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__Documentation); }
      public:
        /// Constructor with default initializations
        wstop__Documentation() : __any(), __mixed(), soap() { }
        virtual ~wstop__Documentation() { }
        /// Friend allocator used by soap_new_wstop__Documentation(struct soap*, int)
        friend SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 soap_instantiate_wstop__Documentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:364 */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (137)
/* complex XML schema type 'wstop:ExtensibleDocumented': */
class SOAP_CMAC wstop__ExtensibleDocumented {
      public:
        /// Optional element 'wstop:documentation' of XML schema type 'wstop:Documentation'
        wstop__Documentation *documentation;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wstop__ExtensibleDocumented
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__ExtensibleDocumented; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__ExtensibleDocumented, default initialized and not managed by a soap context
        virtual wstop__ExtensibleDocumented *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__ExtensibleDocumented); }
      public:
        /// Constructor with default initializations
        wstop__ExtensibleDocumented() : documentation(), __anyAttribute(), soap() { }
        virtual ~wstop__ExtensibleDocumented() { }
        /// Friend allocator used by soap_new_wstop__ExtensibleDocumented(struct soap*, int)
        friend SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_wstop__ExtensibleDocumented(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:366 */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (138)
/* complex XML schema type 'wstop:QueryExpressionType': */
class SOAP_CMAC wstop__QueryExpressionType {
      public:
        /// XML DOM element node graph
        struct soap_dom_element __any;
        /// Required attribute 'Dialect' of XML schema type 'xsd:anyURI'
        std::string Dialect;
        /// XML DOM element node graph
        struct soap_dom_element __mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wstop__QueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__QueryExpressionType, default initialized and not managed by a soap context
        virtual wstop__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__QueryExpressionType); }
      public:
        /// Constructor with default initializations
        wstop__QueryExpressionType() : __any(), Dialect(), __mixed(), soap() { }
        virtual ~wstop__QueryExpressionType() { }
        /// Friend allocator used by soap_new_wstop__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wstop__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:262 */
#ifndef SOAP_TYPE_wsrfr__ResourceUnknownFaultType
#define SOAP_TYPE_wsrfr__ResourceUnknownFaultType (86)
/* complex XML schema type 'wsrfr:ResourceUnknownFaultType': */
class SOAP_CMAC wsrfr__ResourceUnknownFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsrfr__ResourceUnknownFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsrfr__ResourceUnknownFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrfr__ResourceUnknownFaultType, default initialized and not managed by a soap context
        virtual wsrfr__ResourceUnknownFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrfr__ResourceUnknownFaultType); }
      public:
        /// Constructor with default initializations
        wsrfr__ResourceUnknownFaultType() { }
        virtual ~wsrfr__ResourceUnknownFaultType() { }
        /// Friend allocator used by soap_new_wsrfr__ResourceUnknownFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsrfr__ResourceUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsrfr__ResourceUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:264 */
#ifndef SOAP_TYPE_wsrfr__ResourceUnavailableFaultType
#define SOAP_TYPE_wsrfr__ResourceUnavailableFaultType (87)
/* complex XML schema type 'wsrfr:ResourceUnavailableFaultType': */
class SOAP_CMAC wsrfr__ResourceUnavailableFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsrfr__ResourceUnavailableFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsrfr__ResourceUnavailableFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrfr__ResourceUnavailableFaultType, default initialized and not managed by a soap context
        virtual wsrfr__ResourceUnavailableFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrfr__ResourceUnavailableFaultType); }
      public:
        /// Constructor with default initializations
        wsrfr__ResourceUnavailableFaultType() { }
        virtual ~wsrfr__ResourceUnavailableFaultType() { }
        /// Friend allocator used by soap_new_wsrfr__ResourceUnavailableFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsrfr__ResourceUnavailableFaultType * SOAP_FMAC2 soap_instantiate_wsrfr__ResourceUnavailableFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:278 */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (94)
/* complex XML schema type 'wsnt:SubscribeCreationFailedFaultType': */
class SOAP_CMAC wsnt__SubscribeCreationFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__SubscribeCreationFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__SubscribeCreationFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__SubscribeCreationFailedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__SubscribeCreationFailedFaultType() { }
        virtual ~wsnt__SubscribeCreationFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__SubscribeCreationFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:280 */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (95)
/* complex XML schema type 'wsnt:InvalidFilterFaultType': */
class SOAP_CMAC wsnt__InvalidFilterFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:UnknownFilter' of XML schema type 'xsd:QName'
        std::vector<std::string> UnknownFilter;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidFilterFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidFilterFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidFilterFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidFilterFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidFilterFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidFilterFaultType() : UnknownFilter() { }
        virtual ~wsnt__InvalidFilterFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidFilterFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidFilterFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:282 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (96)
/* complex XML schema type 'wsnt:TopicExpressionDialectUnknownFaultType': */
class SOAP_CMAC wsnt__TopicExpressionDialectUnknownFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicExpressionDialectUnknownFaultType, default initialized and not managed by a soap context
        virtual wsnt__TopicExpressionDialectUnknownFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicExpressionDialectUnknownFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__TopicExpressionDialectUnknownFaultType() { }
        virtual ~wsnt__TopicExpressionDialectUnknownFaultType() { }
        /// Friend allocator used by soap_new_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:284 */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (97)
/* complex XML schema type 'wsnt:InvalidTopicExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidTopicExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidTopicExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidTopicExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidTopicExpressionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidTopicExpressionFaultType() { }
        virtual ~wsnt__InvalidTopicExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidTopicExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:286 */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (98)
/* complex XML schema type 'wsnt:TopicNotSupportedFaultType': */
class SOAP_CMAC wsnt__TopicNotSupportedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicNotSupportedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicNotSupportedFaultType, default initialized and not managed by a soap context
        virtual wsnt__TopicNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicNotSupportedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__TopicNotSupportedFaultType() { }
        virtual ~wsnt__TopicNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__TopicNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:288 */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (99)
/* complex XML schema type 'wsnt:MultipleTopicsSpecifiedFaultType': */
class SOAP_CMAC wsnt__MultipleTopicsSpecifiedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__MultipleTopicsSpecifiedFaultType, default initialized and not managed by a soap context
        virtual wsnt__MultipleTopicsSpecifiedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__MultipleTopicsSpecifiedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__MultipleTopicsSpecifiedFaultType() { }
        virtual ~wsnt__MultipleTopicsSpecifiedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:290 */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (100)
/* complex XML schema type 'wsnt:InvalidProducerPropertiesExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidProducerPropertiesExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidProducerPropertiesExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidProducerPropertiesExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidProducerPropertiesExpressionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidProducerPropertiesExpressionFaultType() { }
        virtual ~wsnt__InvalidProducerPropertiesExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:292 */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (101)
/* complex XML schema type 'wsnt:InvalidMessageContentExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidMessageContentExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidMessageContentExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidMessageContentExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidMessageContentExpressionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidMessageContentExpressionFaultType() { }
        virtual ~wsnt__InvalidMessageContentExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:294 */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (102)
/* complex XML schema type 'wsnt:UnrecognizedPolicyRequestFaultType': */
class SOAP_CMAC wsnt__UnrecognizedPolicyRequestFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Optional element 'wsnt:UnrecognizedPolicy' of XML schema type 'xsd:QName'
        std::vector<std::string> UnrecognizedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnrecognizedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnrecognizedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnrecognizedPolicyRequestFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnrecognizedPolicyRequestFaultType() : UnrecognizedPolicy() { }
        virtual ~wsnt__UnrecognizedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:296 */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (103)
/* complex XML schema type 'wsnt:UnsupportedPolicyRequestFaultType': */
class SOAP_CMAC wsnt__UnsupportedPolicyRequestFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Optional element 'wsnt:UnsupportedPolicy' of XML schema type 'xsd:QName'
        std::vector<std::string> UnsupportedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnsupportedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnsupportedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnsupportedPolicyRequestFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnsupportedPolicyRequestFaultType() : UnsupportedPolicy() { }
        virtual ~wsnt__UnsupportedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:298 */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (104)
/* complex XML schema type 'wsnt:NotifyMessageNotSupportedFaultType': */
class SOAP_CMAC wsnt__NotifyMessageNotSupportedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NotifyMessageNotSupportedFaultType, default initialized and not managed by a soap context
        virtual wsnt__NotifyMessageNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NotifyMessageNotSupportedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__NotifyMessageNotSupportedFaultType() { }
        virtual ~wsnt__NotifyMessageNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:300 */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (105)
/* complex XML schema type 'wsnt:UnacceptableInitialTerminationTimeFaultType': */
class SOAP_CMAC wsnt__UnacceptableInitialTerminationTimeFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:MinimumTime' of XML schema type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'wsnt:MaximumTime' of XML schema type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnacceptableInitialTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnacceptableInitialTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnacceptableInitialTerminationTimeFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnacceptableInitialTerminationTimeFaultType() : MinimumTime(), MaximumTime() { }
        virtual ~wsnt__UnacceptableInitialTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:302 */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (106)
/* complex XML schema type 'wsnt:NoCurrentMessageOnTopicFaultType': */
class SOAP_CMAC wsnt__NoCurrentMessageOnTopicFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NoCurrentMessageOnTopicFaultType, default initialized and not managed by a soap context
        virtual wsnt__NoCurrentMessageOnTopicFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NoCurrentMessageOnTopicFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__NoCurrentMessageOnTopicFaultType() { }
        virtual ~wsnt__NoCurrentMessageOnTopicFaultType() { }
        /// Friend allocator used by soap_new_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:304 */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (107)
/* complex XML schema type 'wsnt:UnableToGetMessagesFaultType': */
class SOAP_CMAC wsnt__UnableToGetMessagesFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToGetMessagesFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToGetMessagesFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToGetMessagesFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToGetMessagesFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToGetMessagesFaultType() { }
        virtual ~wsnt__UnableToGetMessagesFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToGetMessagesFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:306 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (108)
/* complex XML schema type 'wsnt:UnableToDestroyPullPointFaultType': */
class SOAP_CMAC wsnt__UnableToDestroyPullPointFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToDestroyPullPointFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToDestroyPullPointFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToDestroyPullPointFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToDestroyPullPointFaultType() { }
        virtual ~wsnt__UnableToDestroyPullPointFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:308 */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (109)
/* complex XML schema type 'wsnt:UnableToCreatePullPointFaultType': */
class SOAP_CMAC wsnt__UnableToCreatePullPointFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToCreatePullPointFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToCreatePullPointFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToCreatePullPointFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToCreatePullPointFaultType() { }
        virtual ~wsnt__UnableToCreatePullPointFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToCreatePullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:310 */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (110)
/* complex XML schema type 'wsnt:UnacceptableTerminationTimeFaultType': */
class SOAP_CMAC wsnt__UnacceptableTerminationTimeFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:MinimumTime' of XML schema type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'wsnt:MaximumTime' of XML schema type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnacceptableTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnacceptableTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnacceptableTerminationTimeFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnacceptableTerminationTimeFaultType() : MinimumTime(), MaximumTime() { }
        virtual ~wsnt__UnacceptableTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:312 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (111)
/* complex XML schema type 'wsnt:UnableToDestroySubscriptionFaultType': */
class SOAP_CMAC wsnt__UnableToDestroySubscriptionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToDestroySubscriptionFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToDestroySubscriptionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToDestroySubscriptionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToDestroySubscriptionFaultType() { }
        virtual ~wsnt__UnableToDestroySubscriptionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:314 */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (112)
/* complex XML schema type 'wsnt:PauseFailedFaultType': */
class SOAP_CMAC wsnt__PauseFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__PauseFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__PauseFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__PauseFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__PauseFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__PauseFailedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__PauseFailedFaultType() { }
        virtual ~wsnt__PauseFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__PauseFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__PauseFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:316 */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (113)
/* complex XML schema type 'wsnt:ResumeFailedFaultType': */
class SOAP_CMAC wsnt__ResumeFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__ResumeFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__ResumeFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__ResumeFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__ResumeFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__ResumeFailedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__ResumeFailedFaultType() { }
        virtual ~wsnt__ResumeFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__ResumeFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__ResumeFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:4645 */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (181)
/* complex XML schema type 'wstop:TopicNamespaceType-Topic': */
class SOAP_CMAC _wstop__TopicNamespaceType_Topic {
      public:
        /// Optional element 'wstop:documentation' of XML schema type 'wstop:Documentation'
        wstop__Documentation *documentation;
        /// XML DOM attribute list
        /// Typedef xsd__anyAttribute with custom serializer for struct soap_dom_attribute
        struct soap_dom_attribute __anyAttribute;
        /// Optional element 'wstop:MessagePattern' of XML schema type 'wstop:QueryExpressionType'
        wstop__QueryExpressionType *MessagePattern;
        /// Optional element 'wstop:Topic' of XML schema type 'wstop:TopicType'
        std::vector<wstop__TopicType *> Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Required attribute 'name' of XML schema type 'xsd:NCName'
        std::string name;
        /// Optional attribute 'messageTypes' of XML schema type 'xsd:QName'
        std::string *messageTypes;
        /// Optional attribute 'final' of XML schema type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
        /// Optional attribute 'parent' of XML schema type 'wstop:ConcreteTopicExpression'
        std::string *parent;
      public:
        /// Return unique type id SOAP_TYPE__wstop__TopicNamespaceType_Topic
        virtual long soap_type(void) const { return SOAP_TYPE__wstop__TopicNamespaceType_Topic; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wstop__TopicNamespaceType_Topic, default initialized and not managed by a soap context
        virtual _wstop__TopicNamespaceType_Topic *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wstop__TopicNamespaceType_Topic); }
      public:
        /// Constructor with default initializations
        _wstop__TopicNamespaceType_Topic() : documentation(), __anyAttribute(), MessagePattern(), Topic(), __any(), name(), messageTypes(), final_((bool)0), parent() { }
        virtual ~_wstop__TopicNamespaceType_Topic() { }
        /// Friend allocator used by soap_new__wstop__TopicNamespaceType_Topic(struct soap*, int)
        friend SOAP_FMAC1 _wstop__TopicNamespaceType_Topic * SOAP_FMAC2 soap_instantiate__wstop__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:368 */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (139)
/* complex XML schema type 'wstop:TopicNamespaceType': */
class SOAP_CMAC wstop__TopicNamespaceType : public wstop__ExtensibleDocumented {
      public:
        /// Optional element 'wstop:Topic' of XML schema type 'wstop:TopicNamespaceType-Topic'
        std::vector<_wstop__TopicNamespaceType_Topic> Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Optional attribute 'name' of XML schema type 'xsd:NCName'
        std::string *name;
        /// Required attribute 'targetNamespace' of XML schema type 'xsd:anyURI'
        std::string targetNamespace;
        /// Optional attribute 'final' of XML schema type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicNamespaceType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicNamespaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicNamespaceType, default initialized and not managed by a soap context
        virtual wstop__TopicNamespaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicNamespaceType); }
      public:
        /// Constructor with default initializations
        wstop__TopicNamespaceType() : Topic(), __any(), name(), targetNamespace(), final_((bool)0) { }
        virtual ~wstop__TopicNamespaceType() { }
        /// Friend allocator used by soap_new_wstop__TopicNamespaceType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_wstop__TopicNamespaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:370 */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (140)
/* Type wstop__TopicType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wstop:TopicType': */
class SOAP_CMAC wstop__TopicType : public wstop__ExtensibleDocumented {
      public:
        /// Optional element 'wstop:MessagePattern' of XML schema type 'wstop:QueryExpressionType'
        wstop__QueryExpressionType *MessagePattern;
        /// Optional element 'wstop:Topic' of XML schema type 'wstop:TopicType'
        std::vector<wstop__TopicType *> Topic;
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
        /// Required attribute 'name' of XML schema type 'xsd:NCName'
        std::string name;
        /// Optional attribute 'messageTypes' of XML schema type 'xsd:QName'
        std::string *messageTypes;
        /// Optional attribute 'final' of XML schema type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicType, default initialized and not managed by a soap context
        virtual wstop__TopicType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicType); }
      public:
        /// Constructor with default initializations
        wstop__TopicType() : MessagePattern(), Topic(), __any(), name(), messageTypes(), final_((bool)0) { }
        virtual ~wstop__TopicType() { }
        /// Friend allocator used by soap_new_wstop__TopicType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 soap_instantiate_wstop__TopicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:372 */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (141)
/* complex XML schema type 'wstop:TopicSetType': */
class SOAP_CMAC wstop__TopicSetType : public wstop__ExtensibleDocumented {
      public:
        /// XML DOM element node graph
        std::vector<struct soap_dom_element> __any;
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicSetType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicSetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicSetType, default initialized and not managed by a soap context
        virtual wstop__TopicSetType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicSetType); }
      public:
        /// Constructor with default initializations
        wstop__TopicSetType() : __any() { }
        virtual ~wstop__TopicSetType() { }
        /// Friend allocator used by soap_new_wstop__TopicSetType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 soap_instantiate_wstop__TopicSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:283 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (48)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        /** XML DOM attribute list */
        struct soap_dom_attribute __anyAttribute;
        /** Optional element 'wsnt:InvalidFilterFault' of XML schema type 'wsnt:InvalidFilterFaultType' */
        wsnt__InvalidFilterFaultType *wsnt__InvalidFilterFault;
        /** Optional element 'wsnt:InvalidMessageContentExpressionFault' of XML schema type 'wsnt:InvalidMessageContentExpressionFaultType' */
        wsnt__InvalidMessageContentExpressionFaultType *wsnt__InvalidMessageContentExpressionFault;
        /** Optional element 'wsnt:InvalidProducerPropertiesExpressionFault' of XML schema type 'wsnt:InvalidProducerPropertiesExpressionFaultType' */
        wsnt__InvalidProducerPropertiesExpressionFaultType *wsnt__InvalidProducerPropertiesExpressionFault;
        /** Optional element 'wsnt:InvalidTopicExpressionFault' of XML schema type 'wsnt:InvalidTopicExpressionFaultType' */
        wsnt__InvalidTopicExpressionFaultType *wsnt__InvalidTopicExpressionFault;
        /** Optional element 'wsnt:MultipleTopicsSpecifiedFault' of XML schema type 'wsnt:MultipleTopicsSpecifiedFaultType' */
        wsnt__MultipleTopicsSpecifiedFaultType *wsnt__MultipleTopicsSpecifiedFault;
        /** Optional element 'wsnt:NoCurrentMessageOnTopicFault' of XML schema type 'wsnt:NoCurrentMessageOnTopicFaultType' */
        wsnt__NoCurrentMessageOnTopicFaultType *wsnt__NoCurrentMessageOnTopicFault;
        /** Optional element 'wsnt:NotifyMessageNotSupportedFault' of XML schema type 'wsnt:NotifyMessageNotSupportedFaultType' */
        wsnt__NotifyMessageNotSupportedFaultType *wsnt__NotifyMessageNotSupportedFault;
        /** Optional element 'wsnt:PauseFailedFault' of XML schema type 'wsnt:PauseFailedFaultType' */
        wsnt__PauseFailedFaultType *wsnt__PauseFailedFault;
        /** Optional element 'tev:PullMessagesFaultResponse' of XML schema type 'tev:PullMessagesFaultResponse' */
        _tev__PullMessagesFaultResponse *tev__PullMessagesFaultResponse;
        /** Optional element 'wsrfr:ResourceUnknownFault' of XML schema type 'wsrfr:ResourceUnknownFaultType' */
        wsrfr__ResourceUnknownFaultType *wsrfr__ResourceUnknownFault;
        /** Optional element 'wsnt:ResumeFailedFault' of XML schema type 'wsnt:ResumeFailedFaultType' */
        wsnt__ResumeFailedFaultType *wsnt__ResumeFailedFault;
        /** Optional element 'wsnt:SubscribeCreationFailedFault' of XML schema type 'wsnt:SubscribeCreationFailedFaultType' */
        wsnt__SubscribeCreationFailedFaultType *wsnt__SubscribeCreationFailedFault;
        /** Optional element 'wsnt:TopicExpressionDialectUnknownFault' of XML schema type 'wsnt:TopicExpressionDialectUnknownFaultType' */
        wsnt__TopicExpressionDialectUnknownFaultType *wsnt__TopicExpressionDialectUnknownFault;
        /** Optional element 'wsnt:TopicNotSupportedFault' of XML schema type 'wsnt:TopicNotSupportedFaultType' */
        wsnt__TopicNotSupportedFaultType *wsnt__TopicNotSupportedFault;
        /** Optional element 'wsnt:UnableToCreatePullPointFault' of XML schema type 'wsnt:UnableToCreatePullPointFaultType' */
        wsnt__UnableToCreatePullPointFaultType *wsnt__UnableToCreatePullPointFault;
        /** Optional element 'wsnt:UnableToDestroyPullPointFault' of XML schema type 'wsnt:UnableToDestroyPullPointFaultType' */
        wsnt__UnableToDestroyPullPointFaultType *wsnt__UnableToDestroyPullPointFault;
        /** Optional element 'wsnt:UnableToDestroySubscriptionFault' of XML schema type 'wsnt:UnableToDestroySubscriptionFaultType' */
        wsnt__UnableToDestroySubscriptionFaultType *wsnt__UnableToDestroySubscriptionFault;
        /** Optional element 'wsnt:UnableToGetMessagesFault' of XML schema type 'wsnt:UnableToGetMessagesFaultType' */
        wsnt__UnableToGetMessagesFaultType *wsnt__UnableToGetMessagesFault;
        /** Optional element 'wsnt:UnacceptableInitialTerminationTimeFault' of XML schema type 'wsnt:UnacceptableInitialTerminationTimeFaultType' */
        wsnt__UnacceptableInitialTerminationTimeFaultType *wsnt__UnacceptableInitialTerminationTimeFault;
        /** Optional element 'wsnt:UnacceptableTerminationTimeFault' of XML schema type 'wsnt:UnacceptableTerminationTimeFaultType' */
        wsnt__UnacceptableTerminationTimeFaultType *wsnt__UnacceptableTerminationTimeFault;
        /** Optional element 'wsnt:UnrecognizedPolicyRequestFault' of XML schema type 'wsnt:UnrecognizedPolicyRequestFaultType' */
        wsnt__UnrecognizedPolicyRequestFaultType *wsnt__UnrecognizedPolicyRequestFault;
        /** Optional element 'wsnt:UnsupportedPolicyRequestFault' of XML schema type 'wsnt:UnsupportedPolicyRequestFaultType' */
        wsnt__UnsupportedPolicyRequestFaultType *wsnt__UnsupportedPolicyRequestFault;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
        char *__any;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __anyAttribute(), wsnt__InvalidFilterFault(), wsnt__InvalidMessageContentExpressionFault(), wsnt__InvalidProducerPropertiesExpressionFault(), wsnt__InvalidTopicExpressionFault(), wsnt__MultipleTopicsSpecifiedFault(), wsnt__NoCurrentMessageOnTopicFault(), wsnt__NotifyMessageNotSupportedFault(), wsnt__PauseFailedFault(), tev__PullMessagesFaultResponse(), wsrfr__ResourceUnknownFault(), wsnt__ResumeFailedFault(), wsnt__SubscribeCreationFailedFault(), wsnt__TopicExpressionDialectUnknownFault(), wsnt__TopicNotSupportedFault(), wsnt__UnableToCreatePullPointFault(), wsnt__UnableToDestroyPullPointFault(), wsnt__UnableToDestroySubscriptionFault(), wsnt__UnableToGetMessagesFault(), wsnt__UnacceptableInitialTerminationTimeFault(), wsnt__UnacceptableTerminationTimeFault(), wsnt__UnrecognizedPolicyRequestFault(), wsnt__UnsupportedPolicyRequestFault(), __type(), fault(), __any() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5266 */
#ifndef SOAP_TYPE___tev__PullMessages
#define SOAP_TYPE___tev__PullMessages (215)
/* Wrapper: */
struct SOAP_CMAC __tev__PullMessages {
      public:
        /** Optional element 'tev:PullMessages' of XML schema type 'tev:PullMessages' */
        _tev__PullMessages *tev__PullMessages;
      public:
        /** Return unique type id SOAP_TYPE___tev__PullMessages */
        long soap_type() const { return SOAP_TYPE___tev__PullMessages; }
        /** Constructor with member initializations */
        __tev__PullMessages() : tev__PullMessages() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__PullMessages * SOAP_FMAC2 soap_instantiate___tev__PullMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5347 */
#ifndef SOAP_TYPE___tev__Seek
#define SOAP_TYPE___tev__Seek (219)
/* Wrapper: */
struct SOAP_CMAC __tev__Seek {
      public:
        /** Optional element 'tev:Seek' of XML schema type 'tev:Seek' */
        _tev__Seek *tev__Seek;
      public:
        /** Return unique type id SOAP_TYPE___tev__Seek */
        long soap_type() const { return SOAP_TYPE___tev__Seek; }
        /** Constructor with member initializations */
        __tev__Seek() : tev__Seek() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Seek * SOAP_FMAC2 soap_instantiate___tev__Seek(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5430 */
#ifndef SOAP_TYPE___tev__SetSynchronizationPoint
#define SOAP_TYPE___tev__SetSynchronizationPoint (223)
/* Wrapper: */
struct SOAP_CMAC __tev__SetSynchronizationPoint {
      public:
        /** Optional element 'tev:SetSynchronizationPoint' of XML schema type 'tev:SetSynchronizationPoint' */
        _tev__SetSynchronizationPoint *tev__SetSynchronizationPoint;
      public:
        /** Return unique type id SOAP_TYPE___tev__SetSynchronizationPoint */
        long soap_type() const { return SOAP_TYPE___tev__SetSynchronizationPoint; }
        /** Constructor with member initializations */
        __tev__SetSynchronizationPoint() : tev__SetSynchronizationPoint() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate___tev__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5508 */
#ifndef SOAP_TYPE___tev__Unsubscribe
#define SOAP_TYPE___tev__Unsubscribe (227)
/* Wrapper: */
struct SOAP_CMAC __tev__Unsubscribe {
      public:
        /** Optional element 'wsnt:Unsubscribe' of XML schema type 'wsnt:Unsubscribe' */
        _wsnt__Unsubscribe *wsnt__Unsubscribe;
      public:
        /** Return unique type id SOAP_TYPE___tev__Unsubscribe */
        long soap_type() const { return SOAP_TYPE___tev__Unsubscribe; }
        /** Constructor with member initializations */
        __tev__Unsubscribe() : wsnt__Unsubscribe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Unsubscribe * SOAP_FMAC2 soap_instantiate___tev__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5577 */
#ifndef SOAP_TYPE___tev__GetServiceCapabilities
#define SOAP_TYPE___tev__GetServiceCapabilities (231)
/* Wrapper: */
struct SOAP_CMAC __tev__GetServiceCapabilities {
      public:
        /** Optional element 'tev:GetServiceCapabilities' of XML schema type 'tev:GetServiceCapabilities' */
        _tev__GetServiceCapabilities *tev__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___tev__GetServiceCapabilities */
        long soap_type() const { return SOAP_TYPE___tev__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __tev__GetServiceCapabilities() : tev__GetServiceCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tev__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5687 */
#ifndef SOAP_TYPE___tev__CreatePullPointSubscription
#define SOAP_TYPE___tev__CreatePullPointSubscription (235)
/* Wrapper: */
struct SOAP_CMAC __tev__CreatePullPointSubscription {
      public:
        /** Optional element 'tev:CreatePullPointSubscription' of XML schema type 'tev:CreatePullPointSubscription' */
        _tev__CreatePullPointSubscription *tev__CreatePullPointSubscription;
      public:
        /** Return unique type id SOAP_TYPE___tev__CreatePullPointSubscription */
        long soap_type() const { return SOAP_TYPE___tev__CreatePullPointSubscription; }
        /** Constructor with member initializations */
        __tev__CreatePullPointSubscription() : tev__CreatePullPointSubscription() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__CreatePullPointSubscription * SOAP_FMAC2 soap_instantiate___tev__CreatePullPointSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5762 */
#ifndef SOAP_TYPE___tev__GetEventProperties
#define SOAP_TYPE___tev__GetEventProperties (239)
/* Wrapper: */
struct SOAP_CMAC __tev__GetEventProperties {
      public:
        /** Optional element 'tev:GetEventProperties' of XML schema type 'tev:GetEventProperties' */
        _tev__GetEventProperties *tev__GetEventProperties;
      public:
        /** Return unique type id SOAP_TYPE___tev__GetEventProperties */
        long soap_type() const { return SOAP_TYPE___tev__GetEventProperties; }
        /** Constructor with member initializations */
        __tev__GetEventProperties() : tev__GetEventProperties() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__GetEventProperties * SOAP_FMAC2 soap_instantiate___tev__GetEventProperties(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5833 */
#ifndef SOAP_TYPE___tev__AddEventBroker
#define SOAP_TYPE___tev__AddEventBroker (243)
/* Wrapper: */
struct SOAP_CMAC __tev__AddEventBroker {
      public:
        /** Optional element 'tev:AddEventBroker' of XML schema type 'tev:AddEventBroker' */
        _tev__AddEventBroker *tev__AddEventBroker;
      public:
        /** Return unique type id SOAP_TYPE___tev__AddEventBroker */
        long soap_type() const { return SOAP_TYPE___tev__AddEventBroker; }
        /** Constructor with member initializations */
        __tev__AddEventBroker() : tev__AddEventBroker() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__AddEventBroker * SOAP_FMAC2 soap_instantiate___tev__AddEventBroker(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5902 */
#ifndef SOAP_TYPE___tev__DeleteEventBroker
#define SOAP_TYPE___tev__DeleteEventBroker (247)
/* Wrapper: */
struct SOAP_CMAC __tev__DeleteEventBroker {
      public:
        /** Optional element 'tev:DeleteEventBroker' of XML schema type 'tev:DeleteEventBroker' */
        _tev__DeleteEventBroker *tev__DeleteEventBroker;
      public:
        /** Return unique type id SOAP_TYPE___tev__DeleteEventBroker */
        long soap_type() const { return SOAP_TYPE___tev__DeleteEventBroker; }
        /** Constructor with member initializations */
        __tev__DeleteEventBroker() : tev__DeleteEventBroker() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__DeleteEventBroker * SOAP_FMAC2 soap_instantiate___tev__DeleteEventBroker(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:5971 */
#ifndef SOAP_TYPE___tev__GetEventBrokers
#define SOAP_TYPE___tev__GetEventBrokers (251)
/* Wrapper: */
struct SOAP_CMAC __tev__GetEventBrokers {
      public:
        /** Optional element 'tev:GetEventBrokers' of XML schema type 'tev:GetEventBrokers' */
        _tev__GetEventBrokers *tev__GetEventBrokers;
      public:
        /** Return unique type id SOAP_TYPE___tev__GetEventBrokers */
        long soap_type() const { return SOAP_TYPE___tev__GetEventBrokers; }
        /** Constructor with member initializations */
        __tev__GetEventBrokers() : tev__GetEventBrokers() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__GetEventBrokers * SOAP_FMAC2 soap_instantiate___tev__GetEventBrokers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6044 */
#ifndef SOAP_TYPE___tev__Renew
#define SOAP_TYPE___tev__Renew (255)
/* Wrapper: */
struct SOAP_CMAC __tev__Renew {
      public:
        /** Optional element 'wsnt:Renew' of XML schema type 'wsnt:Renew' */
        _wsnt__Renew *wsnt__Renew;
      public:
        /** Return unique type id SOAP_TYPE___tev__Renew */
        long soap_type() const { return SOAP_TYPE___tev__Renew; }
        /** Constructor with member initializations */
        __tev__Renew() : wsnt__Renew() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Renew * SOAP_FMAC2 soap_instantiate___tev__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6117 */
#ifndef SOAP_TYPE___tev__Unsubscribe_
#define SOAP_TYPE___tev__Unsubscribe_ (257)
/* Wrapper: */
struct SOAP_CMAC __tev__Unsubscribe_ {
      public:
        /** Optional element 'wsnt:Unsubscribe' of XML schema type 'wsnt:Unsubscribe' */
        _wsnt__Unsubscribe *wsnt__Unsubscribe;
      public:
        /** Return unique type id SOAP_TYPE___tev__Unsubscribe_ */
        long soap_type() const { return SOAP_TYPE___tev__Unsubscribe_; }
        /** Constructor with member initializations */
        __tev__Unsubscribe_() : wsnt__Unsubscribe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Unsubscribe_ * SOAP_FMAC2 soap_instantiate___tev__Unsubscribe_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6220 */
#ifndef SOAP_TYPE___tev__Subscribe
#define SOAP_TYPE___tev__Subscribe (261)
/* Wrapper: */
struct SOAP_CMAC __tev__Subscribe {
      public:
        /** Optional element 'wsnt:Subscribe' of XML schema type 'wsnt:Subscribe' */
        _wsnt__Subscribe *wsnt__Subscribe;
      public:
        /** Return unique type id SOAP_TYPE___tev__Subscribe */
        long soap_type() const { return SOAP_TYPE___tev__Subscribe; }
        /** Constructor with member initializations */
        __tev__Subscribe() : wsnt__Subscribe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Subscribe * SOAP_FMAC2 soap_instantiate___tev__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6305 */
#ifndef SOAP_TYPE___tev__GetCurrentMessage
#define SOAP_TYPE___tev__GetCurrentMessage (265)
/* Wrapper: */
struct SOAP_CMAC __tev__GetCurrentMessage {
      public:
        /** Optional element 'wsnt:GetCurrentMessage' of XML schema type 'wsnt:GetCurrentMessage' */
        _wsnt__GetCurrentMessage *wsnt__GetCurrentMessage;
      public:
        /** Return unique type id SOAP_TYPE___tev__GetCurrentMessage */
        long soap_type() const { return SOAP_TYPE___tev__GetCurrentMessage; }
        /** Constructor with member initializations */
        __tev__GetCurrentMessage() : wsnt__GetCurrentMessage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__GetCurrentMessage * SOAP_FMAC2 soap_instantiate___tev__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6368 */
#ifndef SOAP_TYPE___tev__Notify
#define SOAP_TYPE___tev__Notify (268)
/* Wrapper: */
struct SOAP_CMAC __tev__Notify {
      public:
        /** Optional element 'wsnt:Notify' of XML schema type 'wsnt:Notify' */
        _wsnt__Notify *wsnt__Notify;
      public:
        /** Return unique type id SOAP_TYPE___tev__Notify */
        long soap_type() const { return SOAP_TYPE___tev__Notify; }
        /** Constructor with member initializations */
        __tev__Notify() : wsnt__Notify() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Notify * SOAP_FMAC2 soap_instantiate___tev__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6441 */
#ifndef SOAP_TYPE___tev__GetMessages
#define SOAP_TYPE___tev__GetMessages (272)
/* Wrapper: */
struct SOAP_CMAC __tev__GetMessages {
      public:
        /** Optional element 'wsnt:GetMessages' of XML schema type 'wsnt:GetMessages' */
        _wsnt__GetMessages *wsnt__GetMessages;
      public:
        /** Return unique type id SOAP_TYPE___tev__GetMessages */
        long soap_type() const { return SOAP_TYPE___tev__GetMessages; }
        /** Constructor with member initializations */
        __tev__GetMessages() : wsnt__GetMessages() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__GetMessages * SOAP_FMAC2 soap_instantiate___tev__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6514 */
#ifndef SOAP_TYPE___tev__DestroyPullPoint
#define SOAP_TYPE___tev__DestroyPullPoint (276)
/* Wrapper: */
struct SOAP_CMAC __tev__DestroyPullPoint {
      public:
        /** Optional element 'wsnt:DestroyPullPoint' of XML schema type 'wsnt:DestroyPullPoint' */
        _wsnt__DestroyPullPoint *wsnt__DestroyPullPoint;
      public:
        /** Return unique type id SOAP_TYPE___tev__DestroyPullPoint */
        long soap_type() const { return SOAP_TYPE___tev__DestroyPullPoint; }
        /** Constructor with member initializations */
        __tev__DestroyPullPoint() : wsnt__DestroyPullPoint() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__DestroyPullPoint * SOAP_FMAC2 soap_instantiate___tev__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6577 */
#ifndef SOAP_TYPE___tev__Notify_
#define SOAP_TYPE___tev__Notify_ (278)
/* Wrapper: */
struct SOAP_CMAC __tev__Notify_ {
      public:
        /** Optional element 'wsnt:Notify' of XML schema type 'wsnt:Notify' */
        _wsnt__Notify *wsnt__Notify;
      public:
        /** Return unique type id SOAP_TYPE___tev__Notify_ */
        long soap_type() const { return SOAP_TYPE___tev__Notify_; }
        /** Constructor with member initializations */
        __tev__Notify_() : wsnt__Notify() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Notify_ * SOAP_FMAC2 soap_instantiate___tev__Notify_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6647 */
#ifndef SOAP_TYPE___tev__CreatePullPoint
#define SOAP_TYPE___tev__CreatePullPoint (282)
/* Wrapper: */
struct SOAP_CMAC __tev__CreatePullPoint {
      public:
        /** Optional element 'wsnt:CreatePullPoint' of XML schema type 'wsnt:CreatePullPoint' */
        _wsnt__CreatePullPoint *wsnt__CreatePullPoint;
      public:
        /** Return unique type id SOAP_TYPE___tev__CreatePullPoint */
        long soap_type() const { return SOAP_TYPE___tev__CreatePullPoint; }
        /** Constructor with member initializations */
        __tev__CreatePullPoint() : wsnt__CreatePullPoint() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__CreatePullPoint * SOAP_FMAC2 soap_instantiate___tev__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6720 */
#ifndef SOAP_TYPE___tev__Renew_
#define SOAP_TYPE___tev__Renew_ (284)
/* Wrapper: */
struct SOAP_CMAC __tev__Renew_ {
      public:
        /** Optional element 'wsnt:Renew' of XML schema type 'wsnt:Renew' */
        _wsnt__Renew *wsnt__Renew;
      public:
        /** Return unique type id SOAP_TYPE___tev__Renew_ */
        long soap_type() const { return SOAP_TYPE___tev__Renew_; }
        /** Constructor with member initializations */
        __tev__Renew_() : wsnt__Renew() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Renew_ * SOAP_FMAC2 soap_instantiate___tev__Renew_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6793 */
#ifndef SOAP_TYPE___tev__Unsubscribe__
#define SOAP_TYPE___tev__Unsubscribe__ (286)
/* Wrapper: */
struct SOAP_CMAC __tev__Unsubscribe__ {
      public:
        /** Optional element 'wsnt:Unsubscribe' of XML schema type 'wsnt:Unsubscribe' */
        _wsnt__Unsubscribe *wsnt__Unsubscribe;
      public:
        /** Return unique type id SOAP_TYPE___tev__Unsubscribe__ */
        long soap_type() const { return SOAP_TYPE___tev__Unsubscribe__; }
        /** Constructor with member initializations */
        __tev__Unsubscribe__() : wsnt__Unsubscribe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Unsubscribe__ * SOAP_FMAC2 soap_instantiate___tev__Unsubscribe__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6866 */
#ifndef SOAP_TYPE___tev__PauseSubscription
#define SOAP_TYPE___tev__PauseSubscription (290)
/* Wrapper: */
struct SOAP_CMAC __tev__PauseSubscription {
      public:
        /** Optional element 'wsnt:PauseSubscription' of XML schema type 'wsnt:PauseSubscription' */
        _wsnt__PauseSubscription *wsnt__PauseSubscription;
      public:
        /** Return unique type id SOAP_TYPE___tev__PauseSubscription */
        long soap_type() const { return SOAP_TYPE___tev__PauseSubscription; }
        /** Constructor with member initializations */
        __tev__PauseSubscription() : wsnt__PauseSubscription() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__PauseSubscription * SOAP_FMAC2 soap_instantiate___tev__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:6939 */
#ifndef SOAP_TYPE___tev__ResumeSubscription
#define SOAP_TYPE___tev__ResumeSubscription (294)
/* Wrapper: */
struct SOAP_CMAC __tev__ResumeSubscription {
      public:
        /** Optional element 'wsnt:ResumeSubscription' of XML schema type 'wsnt:ResumeSubscription' */
        _wsnt__ResumeSubscription *wsnt__ResumeSubscription;
      public:
        /** Return unique type id SOAP_TYPE___tev__ResumeSubscription */
        long soap_type() const { return SOAP_TYPE___tev__ResumeSubscription; }
        /** Constructor with member initializations */
        __tev__ResumeSubscription() : wsnt__ResumeSubscription() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__ResumeSubscription * SOAP_FMAC2 soap_instantiate___tev__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsu.h:77 */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (296)
/* complex XML schema type 'wsu:Timestamp': */
struct SOAP_CMAC _wsu__Timestamp {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsu:Created' of XML schema type 'xsd:string' */
        char *Created;
        /** Optional element 'wsu:Expires' of XML schema type 'xsd:string' */
        char *Expires;
      public:
        /** Return unique type id SOAP_TYPE__wsu__Timestamp */
        long soap_type() const { return SOAP_TYPE__wsu__Timestamp; }
        /** Constructor with member initializations */
        _wsu__Timestamp() : wsu__Id(), Created(), Expires() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:74 */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (297)
/* simple XML schema type 'wsse:EncodedString': */
struct SOAP_CMAC wsse__EncodedString {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_wsse__EncodedString */
        long soap_type() const { return SOAP_TYPE_wsse__EncodedString; }
        /** Constructor with member initializations */
        wsse__EncodedString() : __item(), EncodingType(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsse__EncodedString * SOAP_FMAC2 soap_instantiate_wsse__EncodedString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:145 */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (299)
/* complex XML schema type 'wsse:UsernameToken': */
struct SOAP_CMAC _wsse__UsernameToken {
      public:
        /** Optional element 'wsse:Username' of XML schema type 'xsd:string' */
        char *Username;
        /** Optional element 'wsse:Password' of XML schema type 'wsse:Password' */
        struct _wsse__Password *Password;
        /** Optional element 'wsse:Nonce' of XML schema type 'wsse:EncodedString' */
        struct wsse__EncodedString *Nonce;
        /** Optional element 'wsse:Salt' of XML schema type 'xsd:string' */
        char *Salt;
        /** Optional element 'wsse:Iteration' of XML schema type 'xsd:unsignedInt' */
        unsigned int *Iteration;
        /** Optional element 'wsu:Created' of XML schema type 'xsd:string' */
        char *wsu__Created;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE__wsse__UsernameToken */
        long soap_type() const { return SOAP_TYPE__wsse__UsernameToken; }
        /** Constructor with member initializations */
        _wsse__UsernameToken() : Username(), Password(), Nonce(), Salt(), Iteration(), wsu__Created(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:158 */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (305)
/* simple XML schema type 'wsse:BinarySecurityToken': */
struct SOAP_CMAC _wsse__BinarySecurityToken {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__BinarySecurityToken */
        long soap_type() const { return SOAP_TYPE__wsse__BinarySecurityToken; }
        /** Constructor with member initializations */
        _wsse__BinarySecurityToken() : __item(), wsu__Id(), ValueType(), EncodingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:168 */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (306)
/* complex XML schema type 'wsse:Reference': */
struct SOAP_CMAC _wsse__Reference {
      public:
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Reference */
        long soap_type() const { return SOAP_TYPE__wsse__Reference; }
        /** Constructor with member initializations */
        _wsse__Reference() : URI(), ValueType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:176 */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (307)
/* complex XML schema type 'wsse:Embedded': */
struct SOAP_CMAC _wsse__Embedded {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Embedded */
        long soap_type() const { return SOAP_TYPE__wsse__Embedded; }
        /** Constructor with member initializations */
        _wsse__Embedded() : wsu__Id(), ValueType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:185 */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (308)
/* simple XML schema type 'wsse:KeyIdentifier': */
struct SOAP_CMAC _wsse__KeyIdentifier {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__KeyIdentifier */
        long soap_type() const { return SOAP_TYPE__wsse__KeyIdentifier; }
        /** Constructor with member initializations */
        _wsse__KeyIdentifier() : __item(), wsu__Id(), ValueType(), EncodingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:195 */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (309)
/* complex XML schema type 'wsse:SecurityTokenReference': */
struct SOAP_CMAC _wsse__SecurityTokenReference {
      public:
        /** Optional element 'wsse:Reference' of XML schema type 'wsse:Reference' */
        struct _wsse__Reference *Reference;
        /** Optional element 'wsse:KeyIdentifier' of XML schema type 'wsse:KeyIdentifier' */
        struct _wsse__KeyIdentifier *KeyIdentifier;
        /** Optional element 'wsse:Embedded' of XML schema type 'wsse:Embedded' */
        struct _wsse__Embedded *Embedded;
        /** Optional element 'ds:X509Data' of XML schema type 'ds:X509DataType' */
        struct ds__X509DataType *ds__X509Data;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'wsc:Instance' of XML schema type 'xsd:string' */
        char *wsc__Instance;
        /** Optional attribute 'Usage' of XML schema type 'xsd:string' */
        char *Usage;
      public:
        /** Return unique type id SOAP_TYPE__wsse__SecurityTokenReference */
        long soap_type() const { return SOAP_TYPE__wsse__SecurityTokenReference; }
        /** Constructor with member initializations */
        _wsse__SecurityTokenReference() : Reference(), KeyIdentifier(), Embedded(), ds__X509Data(), wsu__Id(), wsc__Instance(), Usage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:38 */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (315)
/* complex XML schema type 'ds:KeyInfoType': */
struct SOAP_CMAC ds__KeyInfoType {
      public:
        /** Optional element 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
        /** Optional element 'ds:KeyName' of XML schema type 'xsd:string' */
        char *KeyName;
        /** Optional element 'ds:KeyValue' of XML schema type 'ds:KeyValueType' */
        struct ds__KeyValueType *KeyValue;
        /** Optional element 'ds:RetrievalMethod' of XML schema type 'ds:RetrievalMethodType' */
        struct ds__RetrievalMethodType *RetrievalMethod;
        /** Optional element 'ds:X509Data' of XML schema type 'ds:X509DataType' */
        struct ds__X509DataType *X509Data;
        /** Optional element 'wsse:SecurityTokenReference' of XML schema type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyInfoType */
        long soap_type() const { return SOAP_TYPE_ds__KeyInfoType; }
        /** Constructor with member initializations */
        ds__KeyInfoType() : xenc__EncryptedKey(), KeyName(), KeyValue(), RetrievalMethod(), X509Data(), wsse__SecurityTokenReference(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:50 */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (319)
/* complex XML schema type 'ds:SignatureType': */
struct SOAP_CMAC ds__SignatureType {
      public:
        /** Optional element 'ds:SignedInfo' of XML schema type 'ds:SignedInfoType' */
        struct ds__SignedInfoType *SignedInfo;
        /** Optional element 'ds:SignatureValue' of XML schema type 'ds:SignatureValue' */
        char *SignatureValue;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *KeyInfo;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureType */
        long soap_type() const { return SOAP_TYPE_ds__SignatureType; }
        /** Constructor with member initializations */
        ds__SignatureType() : SignedInfo(), SignatureValue(), KeyInfo(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* c14n.h:24 */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (328)
/* complex XML schema type 'c14n:InclusiveNamespaces': */
struct SOAP_CMAC _c14n__InclusiveNamespaces {
      public:
        /** Optional attribute 'PrefixList' of XML schema type 'xsd:string' */
        char *PrefixList;
      public:
        /** Return unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
        long soap_type() const { return SOAP_TYPE__c14n__InclusiveNamespaces; }
        /** Constructor with member initializations */
        _c14n__InclusiveNamespaces() : PrefixList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:77 */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (329)
/* complex XML schema type 'ds:TransformType': */
struct SOAP_CMAC ds__TransformType {
      public:
        /** Optional element 'c14n:InclusiveNamespaces' of XML schema type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
        char *__any;
        /** Optional attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformType */
        long soap_type() const { return SOAP_TYPE_ds__TransformType; }
        /** Constructor with member initializations */
        ds__TransformType() : c14n__InclusiveNamespaces(), __any(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:50 */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (320)
/* complex XML schema type 'ds:SignedInfoType': */
struct SOAP_CMAC ds__SignedInfoType {
      public:
        /** Required element 'ds:CanonicalizationMethod' of XML schema type 'ds:CanonicalizationMethodType' */
        struct ds__CanonicalizationMethodType *CanonicalizationMethod;
        /** Required element 'ds:SignatureMethod' of XML schema type 'ds:SignatureMethodType' */
        struct ds__SignatureMethodType *SignatureMethod;
        /** Sequence of elements 'ds:Reference' of XML schema type 'ds:ReferenceType' stored in dynamic array Reference of length __sizeReference */
        int __sizeReference;
        struct ds__ReferenceType **Reference;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignedInfoType */
        long soap_type() const { return SOAP_TYPE_ds__SignedInfoType; }
        /** Constructor with member initializations */
        ds__SignedInfoType() : CanonicalizationMethod(), SignatureMethod(), __sizeReference(), Reference(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:63 */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (324)
/* complex XML schema type 'ds:CanonicalizationMethodType': */
struct SOAP_CMAC ds__CanonicalizationMethodType {
      public:
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'c14n:InclusiveNamespaces' of XML schema type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
      public:
        /** Return unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
        long soap_type() const { return SOAP_TYPE_ds__CanonicalizationMethodType; }
        /** Constructor with member initializations */
        ds__CanonicalizationMethodType() : Algorithm(), c14n__InclusiveNamespaces() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:66 */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (325)
/* complex XML schema type 'ds:SignatureMethodType': */
struct SOAP_CMAC ds__SignatureMethodType {
      public:
        /** Optional element 'ds:HMACOutputLength' of XML schema type 'xsd:int' */
        int *HMACOutputLength;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureMethodType */
        long soap_type() const { return SOAP_TYPE_ds__SignatureMethodType; }
        /** Constructor with member initializations */
        ds__SignatureMethodType() : HMACOutputLength(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:69 */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (326)
/* complex XML schema type 'ds:ReferenceType': */
struct SOAP_CMAC ds__ReferenceType {
      public:
        /** Optional element 'ds:Transforms' of XML schema type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Required element 'ds:DigestMethod' of XML schema type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *DigestMethod;
        /** Required element 'ds:DigestValue' of XML schema type 'xsd:string' */
        char *DigestValue;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__ReferenceType */
        long soap_type() const { return SOAP_TYPE_ds__ReferenceType; }
        /** Constructor with member initializations */
        ds__ReferenceType() : Transforms(), DigestMethod(), DigestValue(), Id(), URI(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:72 */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (327)
/* complex XML schema type 'ds:TransformsType': */
struct SOAP_CMAC ds__TransformsType {
      public:
        /** Sequence of elements 'ds:Transform' of XML schema type 'ds:TransformType' stored in dynamic array Transform of length __sizeTransform */
        int __sizeTransform;
        struct ds__TransformType *Transform;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformsType */
        long soap_type() const { return SOAP_TYPE_ds__TransformsType; }
        /** Constructor with member initializations */
        ds__TransformsType() : __sizeTransform(), Transform() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:83 */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (332)
/* complex XML schema type 'ds:DigestMethodType': */
struct SOAP_CMAC ds__DigestMethodType {
      public:
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__DigestMethodType */
        long soap_type() const { return SOAP_TYPE_ds__DigestMethodType; }
        /** Constructor with member initializations */
        ds__DigestMethodType() : Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:88 */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (333)
/* complex XML schema type 'ds:KeyValueType': */
struct SOAP_CMAC ds__KeyValueType {
      public:
        /** Optional element 'ds:DSAKeyValue' of XML schema type 'ds:DSAKeyValueType' */
        struct ds__DSAKeyValueType *DSAKeyValue;
        /** Optional element 'ds:RSAKeyValue' of XML schema type 'ds:RSAKeyValueType' */
        struct ds__RSAKeyValueType *RSAKeyValue;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__KeyValueType; }
        /** Constructor with member initializations */
        ds__KeyValueType() : DSAKeyValue(), RSAKeyValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:89 */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (335)
/* complex XML schema type 'ds:RetrievalMethodType': */
struct SOAP_CMAC ds__RetrievalMethodType {
      public:
        /** Optional element 'ds:Transforms' of XML schema type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__RetrievalMethodType */
        long soap_type() const { return SOAP_TYPE_ds__RetrievalMethodType; }
        /** Constructor with member initializations */
        ds__RetrievalMethodType() : Transforms(), URI(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:198 */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (313)
/* complex XML schema type 'ds:X509DataType': */
struct SOAP_CMAC ds__X509DataType {
      public:
        /** Optional element 'ds:X509IssuerSerial' of XML schema type 'ds:X509IssuerSerialType' */
        struct ds__X509IssuerSerialType *X509IssuerSerial;
        /** Optional element 'ds:X509SKI' of XML schema type 'xsd:string' */
        char *X509SKI;
        /** Optional element 'ds:X509SubjectName' of XML schema type 'xsd:string' */
        char *X509SubjectName;
        /** Optional element 'ds:X509Certificate' of XML schema type 'xsd:string' */
        char *X509Certificate;
        /** Optional element 'ds:X509CRL' of XML schema type 'xsd:string' */
        char *X509CRL;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509DataType */
        long soap_type() const { return SOAP_TYPE_ds__X509DataType; }
        /** Constructor with member initializations */
        ds__X509DataType() : X509IssuerSerial(), X509SKI(), X509SubjectName(), X509Certificate(), X509CRL() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:106 */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (339)
/* complex XML schema type 'ds:X509IssuerSerialType': */
struct SOAP_CMAC ds__X509IssuerSerialType {
      public:
        /** Required element 'ds:X509IssuerName' of XML schema type 'xsd:string' */
        char *X509IssuerName;
        /** Required element 'ds:X509SerialNumber' of XML schema type 'xsd:string' */
        char *X509SerialNumber;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509IssuerSerialType */
        long soap_type() const { return SOAP_TYPE_ds__X509IssuerSerialType; }
        /** Constructor with member initializations */
        ds__X509IssuerSerialType() : X509IssuerName(), X509SerialNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:127 */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (340)
/* complex XML schema type 'ds:DSAKeyValueType': */
struct SOAP_CMAC ds__DSAKeyValueType {
      public:
        /** Optional element 'ds:G' of XML schema type 'xsd:string' */
        char *G;
        /** Required element 'ds:Y' of XML schema type 'xsd:string' */
        char *Y;
        /** Optional element 'ds:J' of XML schema type 'xsd:string' */
        char *J;
        /** Required element 'ds:P' of XML schema type 'xsd:string' */
        char *P;
        /** Required element 'ds:Q' of XML schema type 'xsd:string' */
        char *Q;
        /** Required element 'ds:Seed' of XML schema type 'xsd:string' */
        char *Seed;
        /** Required element 'ds:PgenCounter' of XML schema type 'xsd:string' */
        char *PgenCounter;
      public:
        /** Return unique type id SOAP_TYPE_ds__DSAKeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__DSAKeyValueType; }
        /** Constructor with member initializations */
        ds__DSAKeyValueType() : G(), Y(), J(), P(), Q(), Seed(), PgenCounter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:130 */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (341)
/* complex XML schema type 'ds:RSAKeyValueType': */
struct SOAP_CMAC ds__RSAKeyValueType {
      public:
        /** Required element 'ds:Modulus' of XML schema type 'xsd:string' */
        char *Modulus;
        /** Required element 'ds:Exponent' of XML schema type 'xsd:string' */
        char *Exponent;
      public:
        /** Return unique type id SOAP_TYPE_ds__RSAKeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__RSAKeyValueType; }
        /** Constructor with member initializations */
        ds__RSAKeyValueType() : Modulus(), Exponent() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:101 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (361)
/* complex XML schema type 'xenc:EncryptionPropertyType': */
struct SOAP_CMAC xenc__EncryptionPropertyType {
      public:
        /** Optional attribute 'Target' of XML schema type 'xsd:string' */
        char *Target;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertyType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertyType() : Target(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:70 */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (352)
/* complex XML schema type 'xenc:EncryptedType': */
struct SOAP_CMAC xenc__EncryptedType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedType; }
        /** Constructor with member initializations */
        xenc__EncryptedType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:73 */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (353)
/* complex XML schema type 'xenc:EncryptionMethodType': */
struct SOAP_CMAC xenc__EncryptionMethodType {
      public:
        /** Optional element 'xenc:KeySize' of XML schema type 'xsd:int' */
        int *KeySize;
        /** Optional element 'xenc:OAEPparams' of XML schema type 'xsd:string' */
        char *OAEPparams;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'ds:DigestMethod' of XML schema type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *ds__DigestMethod;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionMethodType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionMethodType; }
        /** Constructor with member initializations */
        xenc__EncryptionMethodType() : KeySize(), OAEPparams(), Algorithm(), ds__DigestMethod(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:76 */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (354)
/* complex XML schema type 'xenc:CipherDataType': */
struct SOAP_CMAC xenc__CipherDataType {
      public:
        /** Optional element 'xenc:CipherValue' of XML schema type 'xsd:string' */
        char *CipherValue;
        /** Optional element 'xenc:CipherReference' of XML schema type 'xenc:CipherReferenceType' */
        struct xenc__CipherReferenceType *CipherReference;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherDataType */
        long soap_type() const { return SOAP_TYPE_xenc__CipherDataType; }
        /** Constructor with member initializations */
        xenc__CipherDataType() : CipherValue(), CipherReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:79 */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (355)
/* complex XML schema type 'xenc:CipherReferenceType': */
struct SOAP_CMAC xenc__CipherReferenceType {
      public:
        /** Optional element 'xenc:Transforms' of XML schema type 'xenc:TransformsType' */
        struct xenc__TransformsType *Transforms;
        /** Required attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherReferenceType */
        long soap_type() const { return SOAP_TYPE_xenc__CipherReferenceType; }
        /** Constructor with member initializations */
        xenc__CipherReferenceType() : Transforms(), URI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:82 */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (356)
/* complex XML schema type 'xenc:TransformsType': */
struct SOAP_CMAC xenc__TransformsType {
      public:
        /** Required element 'ds:Transform' of XML schema type 'ds:Transform' */
        struct ds__TransformType ds__Transform;
      public:
        /** Return unique type id SOAP_TYPE_xenc__TransformsType */
        long soap_type() const { return SOAP_TYPE_xenc__TransformsType; }
        /** Constructor with member initializations */
        xenc__TransformsType() : ds__Transform() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:91 */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (358)
/* complex XML schema type 'xenc:AgreementMethodType': */
struct SOAP_CMAC xenc__AgreementMethodType {
      public:
        /** Optional element 'xenc:KA-Nonce' of XML schema type 'xsd:string' */
        char *KA_Nonce;
        /** Optional element 'xenc:OriginatorKeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *OriginatorKeyInfo;
        /** Optional element 'xenc:RecipientKeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *RecipientKeyInfo;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__AgreementMethodType */
        long soap_type() const { return SOAP_TYPE_xenc__AgreementMethodType; }
        /** Constructor with member initializations */
        xenc__AgreementMethodType() : KA_Nonce(), OriginatorKeyInfo(), RecipientKeyInfo(), Algorithm(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:94 */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (359)
/* complex XML schema type 'xenc:ReferenceType': */
struct SOAP_CMAC xenc__ReferenceType {
      public:
        /** Required attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__ReferenceType */
        long soap_type() const { return SOAP_TYPE_xenc__ReferenceType; }
        /** Constructor with member initializations */
        xenc__ReferenceType() : URI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:97 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (360)
/* complex XML schema type 'xenc:EncryptionPropertiesType': */
struct SOAP_CMAC xenc__EncryptionPropertiesType {
      public:
        /** Sequence of at least 1 elements 'xenc:EncryptionProperty' of XML schema type 'xenc:EncryptionPropertyType' stored in dynamic array EncryptionProperty of length __sizeEncryptionProperty */
        int __sizeEncryptionProperty;
        struct xenc__EncryptionPropertyType *EncryptionProperty;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertiesType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertiesType() : __sizeEncryptionProperty(), EncryptionProperty(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:253 */
#ifndef SOAP_TYPE___xenc__union_ReferenceList
#define SOAP_TYPE___xenc__union_ReferenceList (370)
/* Wrapper: */
struct SOAP_CMAC __xenc__union_ReferenceList {
      public:
        /** Optional element 'xenc:DataReference' of XML schema type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *DataReference;
        /** Optional element 'xenc:KeyReference' of XML schema type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *KeyReference;
      public:
        /** Return unique type id SOAP_TYPE___xenc__union_ReferenceList */
        long soap_type() const { return SOAP_TYPE___xenc__union_ReferenceList; }
        /** Constructor with member initializations */
        __xenc__union_ReferenceList() : DataReference(), KeyReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:106 */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (362)
/* complex XML schema type 'xenc:ReferenceList': */
struct SOAP_CMAC _xenc__ReferenceList {
      public:
        /** Sequence of at least 1 elements '-union-ReferenceList' of XML schema type '-xenc:union-ReferenceList' stored in dynamic array __union_ReferenceList of length __size_ReferenceList */
        int __size_ReferenceList;
        struct __xenc__union_ReferenceList *__union_ReferenceList;
      public:
        /** Return unique type id SOAP_TYPE__xenc__ReferenceList */
        long soap_type() const { return SOAP_TYPE__xenc__ReferenceList; }
        /** Constructor with member initializations */
        _xenc__ReferenceList() : __size_ReferenceList(), __union_ReferenceList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:85 */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (357)
/* complex XML schema type 'xenc:EncryptedDataType': */
struct SOAP_CMAC xenc__EncryptedDataType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedDataType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedDataType; }
        /** Constructor with member initializations */
        xenc__EncryptedDataType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:39 */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (316)
/* Type xenc__EncryptedKeyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xenc:EncryptedKeyType': */
struct SOAP_CMAC xenc__EncryptedKeyType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
        /** Optional element 'xenc:ReferenceList' of XML schema type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *ReferenceList;
        /** Optional element 'xenc:CarriedKeyName' of XML schema type 'xsd:string' */
        char *CarriedKeyName;
        /** Optional attribute 'Recipient' of XML schema type 'xsd:string' */
        char *Recipient;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedKeyType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedKeyType; }
        /** Constructor with member initializations */
        xenc__EncryptedKeyType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding(), ReferenceList(), CarriedKeyName(), Recipient() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:88 */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (376)
/* complex XML schema type 'wsc:SecurityContextTokenType': */
struct SOAP_CMAC wsc__SecurityContextTokenType {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsc:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
        /** Optional element 'wsc:Instance' of XML schema type 'xsd:string' */
        char *Instance;
      public:
        /** Return unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
        long soap_type() const { return SOAP_TYPE_wsc__SecurityContextTokenType; }
        /** Constructor with member initializations */
        wsc__SecurityContextTokenType() : wsu__Id(), Identifier(), Instance() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:121 */
#ifndef SOAP_TYPE__wsc__union_DerivedKeyTokenType
#define SOAP_TYPE__wsc__union_DerivedKeyTokenType (381)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wsc__union_DerivedKeyTokenType
{
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)	/**< union variant selector value for member Generation */
        ULONG64 Generation;
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)	/**< union variant selector value for member Offset */
        ULONG64 Offset;
};
#endif

/* wsc.h:117 */
#ifndef SOAP_TYPE___wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE___wsc__DerivedKeyTokenType_sequence (380)
/* Wrapper: */
struct SOAP_CMAC __wsc__DerivedKeyTokenType_sequence {
      public:
        /** Union with union _wsc__union_DerivedKeyTokenType variant selector __union_DerivedKeyTokenType set to one of: SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset */
        int __union_DerivedKeyTokenType;
        union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;
        /** Optional element 'wsc:Length' of XML schema type 'xsd:unsignedLong' */
        ULONG64 *Length;
      public:
        /** Return unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
        long soap_type() const { return SOAP_TYPE___wsc__DerivedKeyTokenType_sequence; }
        /** Constructor with member initializations */
        __wsc__DerivedKeyTokenType_sequence() : __union_DerivedKeyTokenType(), Length() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:110 */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (377)
/* complex XML schema type 'wsc:DerivedKeyTokenType': */
struct SOAP_CMAC wsc__DerivedKeyTokenType {
      public:
        /** Optional element 'wsse:SecurityTokenReference' of XML schema type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional element 'wsc:Properties' of XML schema type 'wsc:PropertiesType' */
        struct wsc__PropertiesType *Properties;
        struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
        /** Optional element 'wsc:Label' of XML schema type 'xsd:string' */
        char *Label;
        /** Optional element 'wsc:Nonce' of XML schema type 'xsd:string' */
        char *Nonce;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
        long soap_type() const { return SOAP_TYPE_wsc__DerivedKeyTokenType; }
        /** Constructor with member initializations */
        wsc__DerivedKeyTokenType() : wsse__SecurityTokenReference(), Properties(), __DerivedKeyTokenType_sequence(), Label(), Nonce(), wsu__Id(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:114 */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (378)
/* complex XML schema type 'wsc:PropertiesType': */
struct SOAP_CMAC wsc__PropertiesType {
      public:
        /** Return unique type id SOAP_TYPE_wsc__PropertiesType */
        long soap_type() const { return SOAP_TYPE_wsc__PropertiesType; }
        /** Constructor with member initializations */
        wsc__PropertiesType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:181 */
#ifndef SOAP_TYPE___saml1__union_AssertionType
#define SOAP_TYPE___saml1__union_AssertionType (409)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AssertionType {
      public:
        /** Optional element 'saml1:Statement' of XML schema type 'saml1:StatementAbstractType' */
        struct saml1__StatementAbstractType *saml1__Statement;
        /** Optional element 'saml1:SubjectStatement' of XML schema type 'saml1:SubjectStatementAbstractType' */
        struct saml1__SubjectStatementAbstractType *saml1__SubjectStatement;
        /** Optional element 'saml1:AuthenticationStatement' of XML schema type 'saml1:AuthenticationStatementType' */
        struct saml1__AuthenticationStatementType *saml1__AuthenticationStatement;
        /** Optional element 'saml1:AuthorizationDecisionStatement' of XML schema type 'saml1:AuthorizationDecisionStatementType' */
        struct saml1__AuthorizationDecisionStatementType *saml1__AuthorizationDecisionStatement;
        /** Optional element 'saml1:AttributeStatement' of XML schema type 'saml1:AttributeStatementType' */
        struct saml1__AttributeStatementType *saml1__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AssertionType */
        long soap_type() const { return SOAP_TYPE___saml1__union_AssertionType; }
        /** Constructor with member initializations */
        __saml1__union_AssertionType() : saml1__Statement(), saml1__SubjectStatement(), saml1__AuthenticationStatement(), saml1__AuthorizationDecisionStatement(), saml1__AttributeStatement() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml1__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:75 */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (386)
/* Type saml1__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'saml1:AssertionType': */
struct SOAP_CMAC saml1__AssertionType {
      public:
        /** Optional element 'saml1:Conditions' of XML schema type 'saml1:ConditionsType' */
        struct saml1__ConditionsType *saml1__Conditions;
        /** Optional element 'saml1:Advice' of XML schema type 'saml1:AdviceType' */
        struct saml1__AdviceType *saml1__Advice;
        /** Sequence of elements '-union-AssertionType' of XML schema type '-saml1:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml1__union_AssertionType *__union_AssertionType;
        /** Optional element 'ds:Signature' of XML schema type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Required attribute 'MajorVersion' of XML schema type 'xsd:string' */
        char *MajorVersion;
        /** Required attribute 'MinorVersion' of XML schema type 'xsd:string' */
        char *MinorVersion;
        /** Required attribute 'AssertionID' of XML schema type 'xsd:string' */
        char *AssertionID;
        /** Required attribute 'Issuer' of XML schema type 'xsd:string' */
        char *Issuer;
        /** Required attribute 'IssueInstant' of XML schema type 'xsd:dateTime' */
        struct timeval IssueInstant;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AssertionType */
        long soap_type() const { return SOAP_TYPE_saml1__AssertionType; }
        /** Constructor with member initializations */
        saml1__AssertionType() : saml1__Conditions(), saml1__Advice(), __size_AssertionType(), __union_AssertionType(), ds__Signature(), MajorVersion(), MinorVersion(), AssertionID(), Issuer(), IssueInstant(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AssertionType * SOAP_FMAC2 soap_instantiate_saml1__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:224 */
#ifndef SOAP_TYPE___saml1__union_ConditionsType
#define SOAP_TYPE___saml1__union_ConditionsType (417)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_ConditionsType {
      public:
        /** Optional element 'saml1:AudienceRestrictionCondition' of XML schema type 'saml1:AudienceRestrictionConditionType' */
        struct saml1__AudienceRestrictionConditionType *saml1__AudienceRestrictionCondition;
        /** Optional element 'saml1:DoNotCacheCondition' of XML schema type 'saml1:DoNotCacheConditionType' */
        struct saml1__DoNotCacheConditionType *saml1__DoNotCacheCondition;
        /** Optional element 'saml1:Condition' of XML schema type 'saml1:ConditionAbstractType' */
        struct saml1__ConditionAbstractType *saml1__Condition;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_ConditionsType */
        long soap_type() const { return SOAP_TYPE___saml1__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml1__union_ConditionsType() : saml1__AudienceRestrictionCondition(), saml1__DoNotCacheCondition(), saml1__Condition() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml1__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:78 */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (387)
/* complex XML schema type 'saml1:ConditionsType': */
struct SOAP_CMAC saml1__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XML schema type '-saml1:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml1__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        struct timeval *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionsType */
        long soap_type() const { return SOAP_TYPE_saml1__ConditionsType; }
        /** Constructor with member initializations */
        saml1__ConditionsType() : __size_ConditionsType(), __union_ConditionsType(), NotBefore(), NotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ConditionsType * SOAP_FMAC2 soap_instantiate_saml1__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:81 */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (388)
/* complex XML schema type 'saml1:ConditionAbstractType': */
struct SOAP_CMAC saml1__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml1__ConditionAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml1__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:270 */
#ifndef SOAP_TYPE___saml1__union_AdviceType
#define SOAP_TYPE___saml1__union_AdviceType (423)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AdviceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XML schema type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AdviceType */
        long soap_type() const { return SOAP_TYPE___saml1__union_AdviceType; }
        /** Constructor with member initializations */
        __saml1__union_AdviceType() : saml1__AssertionIDReference(), saml1__Assertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml1__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:90 */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (391)
/* complex XML schema type 'saml1:AdviceType': */
struct SOAP_CMAC saml1__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XML schema type '-saml1:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml1__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AdviceType */
        long soap_type() const { return SOAP_TYPE_saml1__AdviceType; }
        /** Constructor with member initializations */
        saml1__AdviceType() : __size_AdviceType(), __union_AdviceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AdviceType * SOAP_FMAC2 soap_instantiate_saml1__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:93 */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (392)
/* complex XML schema type 'saml1:StatementAbstractType': */
struct SOAP_CMAC saml1__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__StatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__StatementAbstractType; }
        /** Constructor with member initializations */
        saml1__StatementAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:99 */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (394)
/* complex XML schema type 'saml1:SubjectType': */
struct SOAP_CMAC saml1__SubjectType {
      public:
        /** Optional element 'saml1:NameIdentifier' of XML schema type 'saml1:NameIdentifierType' */
        struct saml1__NameIdentifierType *saml1__NameIdentifier;
        /** Optional element 'saml1:SubjectConfirmation' of XML schema type 'saml1:SubjectConfirmationType' */
        struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation;
        /** Optional element 'saml1:SubjectConfirmation' of XML schema type 'saml1:SubjectConfirmationType' */
        struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation_;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectType; }
        /** Constructor with member initializations */
        saml1__SubjectType() : saml1__NameIdentifier(), saml1__SubjectConfirmation(), saml1__SubjectConfirmation_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectType * SOAP_FMAC2 soap_instantiate_saml1__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:105 */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (396)
/* complex XML schema type 'saml1:SubjectConfirmationType': */
struct SOAP_CMAC saml1__SubjectConfirmationType {
      public:
        /** Sequence of at least 1 elements 'saml1:ConfirmationMethod' of XML schema type 'xsd:string' stored in dynamic array saml1__ConfirmationMethod of length __sizeConfirmationMethod */
        int __sizeConfirmationMethod;
        char **saml1__ConfirmationMethod;
        /** Optional element 'saml1:SubjectConfirmationData' of XML schema type 'xsd:anyType' */
        char *saml1__SubjectConfirmationData;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectConfirmationType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml1__SubjectConfirmationType() : __sizeConfirmationMethod(), saml1__ConfirmationMethod(), saml1__SubjectConfirmationData(), ds__KeyInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml1__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:111 */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (398)
/* complex XML schema type 'saml1:SubjectLocalityType': */
struct SOAP_CMAC saml1__SubjectLocalityType {
      public:
        /** Optional attribute 'IPAddress' of XML schema type 'xsd:string' */
        char *IPAddress;
        /** Optional attribute 'DNSAddress' of XML schema type 'xsd:string' */
        char *DNSAddress;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectLocalityType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml1__SubjectLocalityType() : IPAddress(), DNSAddress() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml1__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:114 */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (399)
/* complex XML schema type 'saml1:AuthorityBindingType': */
struct SOAP_CMAC saml1__AuthorityBindingType {
      public:
        /** Required attribute 'AuthorityKind' of XML schema type 'xsd:QName' */
        char *AuthorityKind;
        /** Required attribute 'Location' of XML schema type 'xsd:string' */
        char *Location;
        /** Required attribute 'Binding' of XML schema type 'xsd:string' */
        char *Binding;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorityBindingType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthorityBindingType; }
        /** Constructor with member initializations */
        saml1__AuthorityBindingType() : AuthorityKind(), Location(), Binding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthorityBindingType * SOAP_FMAC2 soap_instantiate_saml1__AuthorityBindingType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:395 */
#ifndef SOAP_TYPE___saml1__union_EvidenceType
#define SOAP_TYPE___saml1__union_EvidenceType (429)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_EvidenceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XML schema type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_EvidenceType */
        long soap_type() const { return SOAP_TYPE___saml1__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml1__union_EvidenceType() : saml1__AssertionIDReference(), saml1__Assertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml1__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:123 */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (402)
/* complex XML schema type 'saml1:EvidenceType': */
struct SOAP_CMAC saml1__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XML schema type '-saml1:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml1__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__EvidenceType */
        long soap_type() const { return SOAP_TYPE_saml1__EvidenceType; }
        /** Constructor with member initializations */
        saml1__EvidenceType() : __size_EvidenceType(), __union_EvidenceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__EvidenceType * SOAP_FMAC2 soap_instantiate_saml1__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:129 */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (404)
/* complex XML schema type 'saml1:AttributeDesignatorType': */
struct SOAP_CMAC saml1__AttributeDesignatorType {
      public:
        /** Required attribute 'AttributeName' of XML schema type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XML schema type 'xsd:string' */
        char *AttributeNamespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeDesignatorType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeDesignatorType; }
        /** Constructor with member initializations */
        saml1__AttributeDesignatorType() : AttributeName(), AttributeNamespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeDesignatorType * SOAP_FMAC2 soap_instantiate_saml1__AttributeDesignatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:84 */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (389)
/* complex XML schema type 'saml1:AudienceRestrictionConditionType': */
struct SOAP_CMAC saml1__AudienceRestrictionConditionType {
      public:
        /** Sequence of at least 1 elements 'saml1:Audience' of XML schema type 'xsd:string' stored in dynamic array saml1__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml1__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AudienceRestrictionConditionType */
        long soap_type() const { return SOAP_TYPE_saml1__AudienceRestrictionConditionType; }
        /** Constructor with member initializations */
        saml1__AudienceRestrictionConditionType() : __sizeAudience(), saml1__Audience() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AudienceRestrictionConditionType * SOAP_FMAC2 soap_instantiate_saml1__AudienceRestrictionConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:87 */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (390)
/* complex XML schema type 'saml1:DoNotCacheConditionType': */
struct SOAP_CMAC saml1__DoNotCacheConditionType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__DoNotCacheConditionType */
        long soap_type() const { return SOAP_TYPE_saml1__DoNotCacheConditionType; }
        /** Constructor with member initializations */
        saml1__DoNotCacheConditionType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__DoNotCacheConditionType * SOAP_FMAC2 soap_instantiate_saml1__DoNotCacheConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:96 */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (393)
/* complex XML schema type 'saml1:SubjectStatementAbstractType': */
struct SOAP_CMAC saml1__SubjectStatementAbstractType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectStatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectStatementAbstractType; }
        /** Constructor with member initializations */
        saml1__SubjectStatementAbstractType() : saml1__Subject() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectStatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__SubjectStatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:102 */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (395)
/* simple XML schema type 'saml1:NameIdentifierType': */
struct SOAP_CMAC saml1__NameIdentifierType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'Format' of XML schema type 'xsd:string' */
        char *Format;
      public:
        /** Return unique type id SOAP_TYPE_saml1__NameIdentifierType */
        long soap_type() const { return SOAP_TYPE_saml1__NameIdentifierType; }
        /** Constructor with member initializations */
        saml1__NameIdentifierType() : __item(), NameQualifier(), Format() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__NameIdentifierType * SOAP_FMAC2 soap_instantiate_saml1__NameIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:120 */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (401)
/* simple XML schema type 'saml1:ActionType': */
struct SOAP_CMAC saml1__ActionType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Namespace' of XML schema type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ActionType */
        long soap_type() const { return SOAP_TYPE_saml1__ActionType; }
        /** Constructor with member initializations */
        saml1__ActionType() : __item(), Namespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ActionType * SOAP_FMAC2 soap_instantiate_saml1__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:132 */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (405)
/* complex XML schema type 'saml1:AttributeType': */
struct SOAP_CMAC saml1__AttributeType {
      public:
        /** Required attribute 'AttributeName' of XML schema type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XML schema type 'xsd:string' */
        char *AttributeNamespace;
        /** Sequence of at least 1 elements 'saml1:AttributeValue' of XML schema type 'xsd:anyType' stored in dynamic array saml1__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml1__AttributeValue;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeType; }
        /** Constructor with member initializations */
        saml1__AttributeType() : AttributeName(), AttributeNamespace(), __sizeAttributeValue(), saml1__AttributeValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeType * SOAP_FMAC2 soap_instantiate_saml1__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:108 */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (397)
/* complex XML schema type 'saml1:AuthenticationStatementType': */
struct SOAP_CMAC saml1__AuthenticationStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Optional element 'saml1:SubjectLocality' of XML schema type 'saml1:SubjectLocalityType' */
        struct saml1__SubjectLocalityType *saml1__SubjectLocality;
        /** Sequence of elements 'saml1:AuthorityBinding' of XML schema type 'saml1:AuthorityBindingType' stored in dynamic array saml1__AuthorityBinding of length __sizeAuthorityBinding */
        int __sizeAuthorityBinding;
        struct saml1__AuthorityBindingType *saml1__AuthorityBinding;
        /** Required attribute 'AuthenticationMethod' of XML schema type 'xsd:string' */
        char *AuthenticationMethod;
        /** Required attribute 'AuthenticationInstant' of XML schema type 'xsd:dateTime' */
        struct timeval AuthenticationInstant;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthenticationStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthenticationStatementType; }
        /** Constructor with member initializations */
        saml1__AuthenticationStatementType() : saml1__Subject(), saml1__SubjectLocality(), __sizeAuthorityBinding(), saml1__AuthorityBinding(), AuthenticationMethod(), AuthenticationInstant() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthenticationStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthenticationStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:117 */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (400)
/* complex XML schema type 'saml1:AuthorizationDecisionStatementType': */
struct SOAP_CMAC saml1__AuthorizationDecisionStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Action' of XML schema type 'saml1:ActionType' stored in dynamic array saml1__Action of length __sizeAction */
        int __sizeAction;
        struct saml1__ActionType *saml1__Action;
        /** Optional element 'saml1:Evidence' of XML schema type 'saml1:EvidenceType' */
        struct saml1__EvidenceType *saml1__Evidence;
        /** Required attribute 'Resource' of XML schema type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XML schema type 'saml1:DecisionType' */
        enum saml1__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorizationDecisionStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthorizationDecisionStatementType; }
        /** Constructor with member initializations */
        saml1__AuthorizationDecisionStatementType() : saml1__Subject(), __sizeAction(), saml1__Action(), saml1__Evidence(), Resource(), Decision() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthorizationDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthorizationDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:126 */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (403)
/* complex XML schema type 'saml1:AttributeStatementType': */
struct SOAP_CMAC saml1__AttributeStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Attribute' of XML schema type 'saml1:AttributeType' stored in dynamic array saml1__Attribute of length __sizeAttribute */
        int __sizeAttribute;
        struct saml1__AttributeType *saml1__Attribute;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeStatementType; }
        /** Constructor with member initializations */
        saml1__AttributeStatementType() : saml1__Subject(), __sizeAttribute(), saml1__Attribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml1__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:75 */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (462)
/* complex XML schema type 'saml2:BaseIDAbstractType': */
struct SOAP_CMAC saml2__BaseIDAbstractType {
      public:
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XML schema type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__BaseIDAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__BaseIDAbstractType; }
        /** Constructor with member initializations */
        saml2__BaseIDAbstractType() : NameQualifier(), SPNameQualifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__BaseIDAbstractType * SOAP_FMAC2 soap_instantiate_saml2__BaseIDAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:81 */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (464)
/* complex XML schema type 'saml2:EncryptedElementType': */
struct SOAP_CMAC saml2__EncryptedElementType {
      public:
        /** Required element 'xenc:EncryptedData' of XML schema type 'xenc:EncryptedDataType' */
        struct xenc__EncryptedDataType xenc__EncryptedData;
        /** Sequence of elements 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' stored in dynamic array xenc__EncryptedKey of length __sizexenc__EncryptedKey */
        int __sizexenc__EncryptedKey;
        struct xenc__EncryptedKeyType **xenc__EncryptedKey;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EncryptedElementType */
        long soap_type() const { return SOAP_TYPE_saml2__EncryptedElementType; }
        /** Constructor with member initializations */
        saml2__EncryptedElementType() : xenc__EncryptedData(), __sizexenc__EncryptedKey(), xenc__EncryptedKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__EncryptedElementType * SOAP_FMAC2 soap_instantiate_saml2__EncryptedElementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:234 */
#ifndef SOAP_TYPE___saml2__union_AssertionType
#define SOAP_TYPE___saml2__union_AssertionType (491)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AssertionType {
      public:
        /** Optional element 'saml2:Statement' of XML schema type 'saml2:StatementAbstractType' */
        struct saml2__StatementAbstractType *saml2__Statement;
        /** Optional element 'saml2:AuthnStatement' of XML schema type 'saml2:AuthnStatementType' */
        struct saml2__AuthnStatementType *saml2__AuthnStatement;
        /** Optional element 'saml2:AuthzDecisionStatement' of XML schema type 'saml2:AuthzDecisionStatementType' */
        struct saml2__AuthzDecisionStatementType *saml2__AuthzDecisionStatement;
        /** Optional element 'saml2:AttributeStatement' of XML schema type 'saml2:AttributeStatementType' */
        struct saml2__AttributeStatementType *saml2__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AssertionType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AssertionType; }
        /** Constructor with member initializations */
        __saml2__union_AssertionType() : saml2__Statement(), saml2__AuthnStatement(), saml2__AuthzDecisionStatement(), saml2__AttributeStatement() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml2__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:84 */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (465)
/* Type saml2__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'saml2:AssertionType': */
struct SOAP_CMAC saml2__AssertionType {
      public:
        /** Required element 'saml2:Issuer' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__Issuer;
        /** Optional element 'ds:Signature' of XML schema type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml2:Subject' of XML schema type 'saml2:SubjectType' */
        struct saml2__SubjectType *saml2__Subject;
        /** Optional element 'saml2:Conditions' of XML schema type 'saml2:ConditionsType' */
        struct saml2__ConditionsType *saml2__Conditions;
        /** Optional element 'saml2:Advice' of XML schema type 'saml2:AdviceType' */
        struct saml2__AdviceType *saml2__Advice;
        /** Sequence of elements '-union-AssertionType' of XML schema type '-saml2:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml2__union_AssertionType *__union_AssertionType;
        /** Required attribute 'Version' of XML schema type 'xsd:string' */
        char *Version;
        /** Required attribute 'ID' of XML schema type 'xsd:string' */
        char *ID;
        /** Required attribute 'IssueInstant' of XML schema type 'xsd:dateTime' */
        struct timeval IssueInstant;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AssertionType */
        long soap_type() const { return SOAP_TYPE_saml2__AssertionType; }
        /** Constructor with member initializations */
        saml2__AssertionType() : saml2__Issuer(), ds__Signature(), saml2__Subject(), saml2__Conditions(), saml2__Advice(), __size_AssertionType(), __union_AssertionType(), Version(), ID(), IssueInstant(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AssertionType * SOAP_FMAC2 soap_instantiate_saml2__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:87 */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (466)
/* complex XML schema type 'saml2:SubjectType': */
struct SOAP_CMAC saml2__SubjectType {
      public:
        /** Optional element 'saml2:BaseID' of XML schema type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Sequence of elements 'saml2:SubjectConfirmation' of XML schema type 'saml2:SubjectConfirmationType' stored in dynamic array saml2__SubjectConfirmation of length __sizeSubjectConfirmation */
        int __sizeSubjectConfirmation;
        struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation;
        /** Sequence of elements 'saml2:SubjectConfirmation' of XML schema type 'saml2:SubjectConfirmationType' stored in dynamic array saml2__SubjectConfirmation_ of length __sizeSubjectConfirmation_ */
        int __sizeSubjectConfirmation_;
        struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation_;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectType; }
        /** Constructor with member initializations */
        saml2__SubjectType() : saml2__BaseID(), saml2__NameID(), saml2__EncryptedID(), __sizeSubjectConfirmation(), saml2__SubjectConfirmation(), __sizeSubjectConfirmation_(), saml2__SubjectConfirmation_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectType * SOAP_FMAC2 soap_instantiate_saml2__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:90 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (467)
/* complex XML schema type 'saml2:SubjectConfirmationType': */
struct SOAP_CMAC saml2__SubjectConfirmationType {
      public:
        /** Optional element 'saml2:BaseID' of XML schema type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Optional element 'saml2:SubjectConfirmationData' of XML schema type 'saml2:SubjectConfirmationDataType' */
        struct saml2__SubjectConfirmationDataType *saml2__SubjectConfirmationData;
        /** Required attribute 'Method' of XML schema type 'xsd:string' */
        char *Method;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationType() : saml2__BaseID(), saml2__NameID(), saml2__EncryptedID(), saml2__SubjectConfirmationData(), Method() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:327 */
#ifndef SOAP_TYPE___saml2__union_ConditionsType
#define SOAP_TYPE___saml2__union_ConditionsType (501)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_ConditionsType {
      public:
        /** Optional element 'saml2:Condition' of XML schema type 'saml2:ConditionAbstractType' */
        struct saml2__ConditionAbstractType *saml2__Condition;
        /** Optional element 'saml2:AudienceRestriction' of XML schema type 'saml2:AudienceRestrictionType' */
        struct saml2__AudienceRestrictionType *saml2__AudienceRestriction;
        /** Optional element 'saml2:OneTimeUse' of XML schema type 'saml2:OneTimeUseType' */
        struct saml2__OneTimeUseType *saml2__OneTimeUse;
        /** Optional element 'saml2:ProxyRestriction' of XML schema type 'saml2:ProxyRestrictionType' */
        struct saml2__ProxyRestrictionType *saml2__ProxyRestriction;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_ConditionsType */
        long soap_type() const { return SOAP_TYPE___saml2__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml2__union_ConditionsType() : saml2__Condition(), saml2__AudienceRestriction(), saml2__OneTimeUse(), saml2__ProxyRestriction() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml2__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:99 */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (470)
/* complex XML schema type 'saml2:ConditionsType': */
struct SOAP_CMAC saml2__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XML schema type '-saml2:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml2__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        struct timeval *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionsType */
        long soap_type() const { return SOAP_TYPE_saml2__ConditionsType; }
        /** Constructor with member initializations */
        saml2__ConditionsType() : __size_ConditionsType(), __union_ConditionsType(), NotBefore(), NotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ConditionsType * SOAP_FMAC2 soap_instantiate_saml2__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:102 */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (471)
/* complex XML schema type 'saml2:ConditionAbstractType': */
struct SOAP_CMAC saml2__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml2__ConditionAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml2__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:376 */
#ifndef SOAP_TYPE___saml2__union_AdviceType
#define SOAP_TYPE___saml2__union_AdviceType (507)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AdviceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AdviceType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AdviceType; }
        /** Constructor with member initializations */
        __saml2__union_AdviceType() : saml2__AssertionIDRef(), saml2__AssertionURIRef(), saml2__Assertion(), saml2__EncryptedAssertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml2__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:114 */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (475)
/* complex XML schema type 'saml2:AdviceType': */
struct SOAP_CMAC saml2__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XML schema type '-saml2:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml2__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AdviceType */
        long soap_type() const { return SOAP_TYPE_saml2__AdviceType; }
        /** Constructor with member initializations */
        saml2__AdviceType() : __size_AdviceType(), __union_AdviceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AdviceType * SOAP_FMAC2 soap_instantiate_saml2__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:117 */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (476)
/* complex XML schema type 'saml2:StatementAbstractType': */
struct SOAP_CMAC saml2__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__StatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__StatementAbstractType; }
        /** Constructor with member initializations */
        saml2__StatementAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml2__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:123 */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (478)
/* complex XML schema type 'saml2:SubjectLocalityType': */
struct SOAP_CMAC saml2__SubjectLocalityType {
      public:
        /** Optional attribute 'Address' of XML schema type 'xsd:string' */
        char *Address;
        /** Optional attribute 'DNSName' of XML schema type 'xsd:string' */
        char *DNSName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectLocalityType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml2__SubjectLocalityType() : Address(), DNSName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml2__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:126 */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (479)
/* complex XML schema type 'saml2:AuthnContextType': */
struct SOAP_CMAC saml2__AuthnContextType {
      public:
        /** Optional element 'saml2:AuthnContextClassRef' of XML schema type 'xsd:string' */
        char *saml2__AuthnContextClassRef;
        /** Optional element 'saml2:AuthnContextDecl' of XML schema type 'xsd:anyType' */
        char *saml2__AuthnContextDecl;
        /** Optional element 'saml2:AuthnContextDeclRef' of XML schema type 'xsd:string' */
        char *saml2__AuthnContextDeclRef;
        /** Optional element 'saml2:AuthnContextDecl' of XML schema type 'xsd:anyType' */
        char *saml2__AuthnContextDecl_;
        /** Optional element 'saml2:AuthnContextDeclRef' of XML schema type 'xsd:string' */
        char *saml2__AuthnContextDeclRef_;
        /** Sequence of elements 'saml2:AuthenticatingAuthority' of XML schema type 'xsd:string' stored in dynamic array saml2__AuthenticatingAuthority of length __sizeAuthenticatingAuthority */
        int __sizeAuthenticatingAuthority;
        char **saml2__AuthenticatingAuthority;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnContextType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthnContextType; }
        /** Constructor with member initializations */
        saml2__AuthnContextType() : saml2__AuthnContextClassRef(), saml2__AuthnContextDecl(), saml2__AuthnContextDeclRef(), saml2__AuthnContextDecl_(), saml2__AuthnContextDeclRef_(), __sizeAuthenticatingAuthority(), saml2__AuthenticatingAuthority() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthnContextType * SOAP_FMAC2 soap_instantiate_saml2__AuthnContextType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:479 */
#ifndef SOAP_TYPE___saml2__union_EvidenceType
#define SOAP_TYPE___saml2__union_EvidenceType (510)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_EvidenceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_EvidenceType */
        long soap_type() const { return SOAP_TYPE___saml2__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml2__union_EvidenceType() : saml2__AssertionIDRef(), saml2__AssertionURIRef(), saml2__Assertion(), saml2__EncryptedAssertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml2__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:135 */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (482)
/* complex XML schema type 'saml2:EvidenceType': */
struct SOAP_CMAC saml2__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XML schema type '-saml2:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml2__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EvidenceType */
        long soap_type() const { return SOAP_TYPE_saml2__EvidenceType; }
        /** Constructor with member initializations */
        saml2__EvidenceType() : __size_EvidenceType(), __union_EvidenceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__EvidenceType * SOAP_FMAC2 soap_instantiate_saml2__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:141 */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (484)
/* complex XML schema type 'saml2:AttributeType': */
struct SOAP_CMAC saml2__AttributeType {
      public:
        /** Sequence of elements 'saml2:AttributeValue' of XML schema type 'xsd:anyType' stored in dynamic array saml2__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml2__AttributeValue;
        /** Required attribute 'Name' of XML schema type 'xsd:string' */
        char *Name;
        /** Optional attribute 'NameFormat' of XML schema type 'xsd:string' */
        char *NameFormat;
        /** Optional attribute 'FriendlyName' of XML schema type 'xsd:string' */
        char *FriendlyName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeType */
        long soap_type() const { return SOAP_TYPE_saml2__AttributeType; }
        /** Constructor with member initializations */
        saml2__AttributeType() : __sizeAttributeValue(), saml2__AttributeValue(), Name(), NameFormat(), FriendlyName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AttributeType * SOAP_FMAC2 soap_instantiate_saml2__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:78 */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (463)
/* simple XML schema type 'saml2:NameIDType': */
struct SOAP_CMAC saml2__NameIDType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Format' of XML schema type 'xsd:string' */
        char *Format;
        /** Optional attribute 'SPProvidedID' of XML schema type 'xsd:string' */
        char *SPProvidedID;
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XML schema type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__NameIDType */
        long soap_type() const { return SOAP_TYPE_saml2__NameIDType; }
        /** Constructor with member initializations */
        saml2__NameIDType() : __item(), Format(), SPProvidedID(), NameQualifier(), SPNameQualifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__NameIDType * SOAP_FMAC2 soap_instantiate_saml2__NameIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:93 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (468)
/* complex XML schema type 'saml2:SubjectConfirmationDataType': */
struct SOAP_CMAC saml2__SubjectConfirmationDataType {
      public:
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        struct timeval *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *NotOnOrAfter;
        /** Optional attribute 'Recipient' of XML schema type 'xsd:string' */
        char *Recipient;
        /** Optional attribute 'InResponseTo' of XML schema type 'xsd:string' */
        char *InResponseTo;
        /** Optional attribute 'Address' of XML schema type 'xsd:string' */
        char *Address;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationDataType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationDataType() : NotBefore(), NotOnOrAfter(), Recipient(), InResponseTo(), Address(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:105 */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (472)
/* complex XML schema type 'saml2:AudienceRestrictionType': */
struct SOAP_CMAC saml2__AudienceRestrictionType {
      public:
        /** Sequence of at least 1 elements 'saml2:Audience' of XML schema type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AudienceRestrictionType */
        long soap_type() const { return SOAP_TYPE_saml2__AudienceRestrictionType; }
        /** Constructor with member initializations */
        saml2__AudienceRestrictionType() : __sizeAudience(), saml2__Audience() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AudienceRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__AudienceRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:108 */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (473)
/* complex XML schema type 'saml2:OneTimeUseType': */
struct SOAP_CMAC saml2__OneTimeUseType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__OneTimeUseType */
        long soap_type() const { return SOAP_TYPE_saml2__OneTimeUseType; }
        /** Constructor with member initializations */
        saml2__OneTimeUseType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__OneTimeUseType * SOAP_FMAC2 soap_instantiate_saml2__OneTimeUseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:111 */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (474)
/* complex XML schema type 'saml2:ProxyRestrictionType': */
struct SOAP_CMAC saml2__ProxyRestrictionType {
      public:
        /** Sequence of elements 'saml2:Audience' of XML schema type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
        /** Optional attribute 'Count' of XML schema type 'xsd:string' */
        char *Count;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ProxyRestrictionType */
        long soap_type() const { return SOAP_TYPE_saml2__ProxyRestrictionType; }
        /** Constructor with member initializations */
        saml2__ProxyRestrictionType() : __sizeAudience(), saml2__Audience(), Count() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ProxyRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__ProxyRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:120 */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (477)
/* complex XML schema type 'saml2:AuthnStatementType': */
struct SOAP_CMAC saml2__AuthnStatementType {
      public:
        /** Optional element 'saml2:SubjectLocality' of XML schema type 'saml2:SubjectLocalityType' */
        struct saml2__SubjectLocalityType *saml2__SubjectLocality;
        /** Required element 'saml2:AuthnContext' of XML schema type 'saml2:AuthnContextType' */
        struct saml2__AuthnContextType *saml2__AuthnContext;
        /** Required attribute 'AuthnInstant' of XML schema type 'xsd:dateTime' */
        struct timeval AuthnInstant;
        /** Optional attribute 'SessionIndex' of XML schema type 'xsd:string' */
        char *SessionIndex;
        /** Optional attribute 'SessionNotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *SessionNotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthnStatementType; }
        /** Constructor with member initializations */
        saml2__AuthnStatementType() : saml2__SubjectLocality(), saml2__AuthnContext(), AuthnInstant(), SessionIndex(), SessionNotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthnStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthnStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:129 */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (480)
/* complex XML schema type 'saml2:AuthzDecisionStatementType': */
struct SOAP_CMAC saml2__AuthzDecisionStatementType {
      public:
        /** Sequence of at least 1 elements 'saml2:Action' of XML schema type 'saml2:ActionType' stored in dynamic array saml2__Action of length __sizeAction */
        int __sizeAction;
        struct saml2__ActionType *saml2__Action;
        /** Optional element 'saml2:Evidence' of XML schema type 'saml2:EvidenceType' */
        struct saml2__EvidenceType *saml2__Evidence;
        /** Required attribute 'Resource' of XML schema type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XML schema type 'saml2:DecisionType' */
        enum saml2__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthzDecisionStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthzDecisionStatementType; }
        /** Constructor with member initializations */
        saml2__AuthzDecisionStatementType() : __sizeAction(), saml2__Action(), saml2__Evidence(), Resource(), Decision() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthzDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthzDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:132 */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (481)
/* simple XML schema type 'saml2:ActionType': */
struct SOAP_CMAC saml2__ActionType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Required attribute 'Namespace' of XML schema type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ActionType */
        long soap_type() const { return SOAP_TYPE_saml2__ActionType; }
        /** Constructor with member initializations */
        saml2__ActionType() : __item(), Namespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ActionType * SOAP_FMAC2 soap_instantiate_saml2__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:729 */
#ifndef SOAP_TYPE___saml2__union_AttributeStatementType
#define SOAP_TYPE___saml2__union_AttributeStatementType (516)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AttributeStatementType {
      public:
        /** Optional element 'saml2:Attribute' of XML schema type 'saml2:AttributeType' */
        struct saml2__AttributeType *saml2__Attribute;
        /** Optional element 'saml2:EncryptedAttribute' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAttribute;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AttributeStatementType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AttributeStatementType; }
        /** Constructor with member initializations */
        __saml2__union_AttributeStatementType() : saml2__Attribute(), saml2__EncryptedAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AttributeStatementType * SOAP_FMAC2 soap_instantiate___saml2__union_AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:138 */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (483)
/* complex XML schema type 'saml2:AttributeStatementType': */
struct SOAP_CMAC saml2__AttributeStatementType {
      public:
        /** Sequence of elements '-union-AttributeStatementType' of XML schema type '-saml2:union-AttributeStatementType' stored in dynamic array __union_AttributeStatementType of length __size_AttributeStatementType */
        int __size_AttributeStatementType;
        struct __saml2__union_AttributeStatementType *__union_AttributeStatementType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AttributeStatementType; }
        /** Constructor with member initializations */
        saml2__AttributeStatementType() : __size_AttributeStatementType(), __union_AttributeStatementType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml2__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:96 */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (469)
/* complex XML schema type 'saml2:KeyInfoConfirmationDataType': */
struct SOAP_CMAC saml2__KeyInfoConfirmationDataType {
      public:
        /** Sequence of at least 1 elements 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' stored in dynamic array ds__KeyInfo of length __sizeds__KeyInfo */
        int __sizeds__KeyInfo;
        struct ds__KeyInfoType **ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml2__KeyInfoConfirmationDataType */
        long soap_type() const { return SOAP_TYPE_saml2__KeyInfoConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__KeyInfoConfirmationDataType() : __sizeds__KeyInfo(), ds__KeyInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__KeyInfoConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__KeyInfoConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:212 */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (553)
/* complex XML schema type 'wsse:Security': */
struct SOAP_CMAC _wsse__Security {
      public:
        /** Optional element 'wsu:Timestamp' of XML schema type 'wsu:Timestamp' */
        struct _wsu__Timestamp *wsu__Timestamp;
        /** Optional element 'wsse:UsernameToken' of XML schema type 'wsse:UsernameToken' */
        struct _wsse__UsernameToken *UsernameToken;
        /** Optional element 'wsse:BinarySecurityToken' of XML schema type 'wsse:BinarySecurityToken' */
        struct _wsse__BinarySecurityToken *BinarySecurityToken;
        /** Optional element 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
        /** Optional element 'xenc:ReferenceList' of XML schema type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *xenc__ReferenceList;
        /** Optional element 'wsc:SecurityContextToken' of XML schema type 'wsc:SecurityContextTokenType' */
        struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;
        /** Optional element 'ds:Signature' of XML schema type 'ds:SignatureType' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional attribute 'SOAP-ENV:actor' of XML schema type 'xsd:string' */
        char *SOAP_ENV__actor;
        /** Optional attribute 'SOAP-ENV:role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__role;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Security */
        long soap_type() const { return SOAP_TYPE__wsse__Security; }
        /** Constructor with member initializations */
        _wsse__Security() : wsu__Timestamp(), UsernameToken(), BinarySecurityToken(), xenc__EncryptedKey(), xenc__ReferenceList(), wsc__SecurityContextToken(), ds__Signature(), saml1__Assertion(), saml2__Assertion(), SOAP_ENV__actor(), SOAP_ENV__role() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:146 */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (300)
/* simple XML schema type 'wsse:Password': */
struct SOAP_CMAC _wsse__Password {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Password */
        long soap_type() const { return SOAP_TYPE__wsse__Password; }
        /** Constructor with member initializations */
        _wsse__Password() : __item(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* wsa5.h:89 */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (17)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

/* wsa5.h:92 */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (18)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

/* wsa5.h:211 */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (25)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

/* wsa5.h:214 */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (26)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

/* wsa5.h:217 */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (27)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

/* wsa5.h:220 */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (28)
typedef char *_wsa5__MessageID;
#endif

/* wsa5.h:223 */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (29)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

/* wsa5.h:226 */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (30)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

/* wsa5.h:229 */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (31)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

/* wsa5.h:232 */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (32)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

/* wsa5.h:235 */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (33)
typedef char *_wsa5__To;
#endif

/* wsa5.h:238 */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (34)
typedef char *_wsa5__Action;
#endif

/* wsa5.h:241 */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (36)
typedef ULONG64 _wsa5__RetryAfter;
#endif

/* wsa5.h:244 */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (37)
typedef _QName _wsa5__ProblemHeaderQName;
#endif

/* wsa5.h:247 */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (38)
typedef char *_wsa5__ProblemIRI;
#endif

/* wsa5.h:250 */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (39)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:192 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (59)
typedef std::string xsd__NCName;
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:195 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (60)
typedef std::string xsd__anyURI;
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:198 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (61)
typedef std::string xsd__duration;
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:201 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (62)
typedef std::string xsd__nonNegativeInteger;
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:204 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (63)
typedef std::string xsd__token;
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:207 */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (64)
typedef std::string _xml__lang;
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:423 */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (142)
typedef std::string wsnt__AbsoluteOrRelativeTimeType;
#endif

/* /home/jbennett/src/zoneminder/build/generated/bindings.h:495 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (143)
typedef std::string wstop__ConcreteTopicExpression;
#endif

/* ds.h:48 */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (318)
typedef char *_ds__SignatureValue;
#endif

/* ds.h:54 */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (323)
typedef struct ds__SignatureType _ds__Signature;
#endif

/* ds.h:80 */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (331)
typedef struct ds__TransformType _ds__Transform;
#endif

/* ds.h:94 */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (338)
typedef struct ds__KeyInfoType _ds__KeyInfo;
#endif

/* wsc.h:58 */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (374)
typedef char *wsc__FaultCodeOpenEnumType;
#endif

/* saml1.h:628 */
#ifndef SOAP_TYPE__saml1__AssertionIDReference
#define SOAP_TYPE__saml1__AssertionIDReference (437)
typedef char *_saml1__AssertionIDReference;
#endif

/* saml1.h:631 */
#ifndef SOAP_TYPE__saml1__Assertion
#define SOAP_TYPE__saml1__Assertion (438)
typedef struct saml1__AssertionType _saml1__Assertion;
#endif

/* saml1.h:634 */
#ifndef SOAP_TYPE__saml1__Conditions
#define SOAP_TYPE__saml1__Conditions (439)
typedef struct saml1__ConditionsType _saml1__Conditions;
#endif

/* saml1.h:637 */
#ifndef SOAP_TYPE__saml1__Condition
#define SOAP_TYPE__saml1__Condition (440)
typedef struct saml1__ConditionAbstractType _saml1__Condition;
#endif

/* saml1.h:640 */
#ifndef SOAP_TYPE__saml1__AudienceRestrictionCondition
#define SOAP_TYPE__saml1__AudienceRestrictionCondition (441)
typedef struct saml1__AudienceRestrictionConditionType _saml1__AudienceRestrictionCondition;
#endif

/* saml1.h:643 */
#ifndef SOAP_TYPE__saml1__Audience
#define SOAP_TYPE__saml1__Audience (442)
typedef char *_saml1__Audience;
#endif

/* saml1.h:646 */
#ifndef SOAP_TYPE__saml1__DoNotCacheCondition
#define SOAP_TYPE__saml1__DoNotCacheCondition (443)
typedef struct saml1__DoNotCacheConditionType _saml1__DoNotCacheCondition;
#endif

/* saml1.h:649 */
#ifndef SOAP_TYPE__saml1__Advice
#define SOAP_TYPE__saml1__Advice (444)
typedef struct saml1__AdviceType _saml1__Advice;
#endif

/* saml1.h:652 */
#ifndef SOAP_TYPE__saml1__Statement
#define SOAP_TYPE__saml1__Statement (445)
typedef struct saml1__StatementAbstractType _saml1__Statement;
#endif

/* saml1.h:655 */
#ifndef SOAP_TYPE__saml1__SubjectStatement
#define SOAP_TYPE__saml1__SubjectStatement (446)
typedef struct saml1__SubjectStatementAbstractType _saml1__SubjectStatement;
#endif

/* saml1.h:658 */
#ifndef SOAP_TYPE__saml1__Subject
#define SOAP_TYPE__saml1__Subject (447)
typedef struct saml1__SubjectType _saml1__Subject;
#endif

/* saml1.h:661 */
#ifndef SOAP_TYPE__saml1__NameIdentifier
#define SOAP_TYPE__saml1__NameIdentifier (448)
typedef struct saml1__NameIdentifierType _saml1__NameIdentifier;
#endif

/* saml1.h:664 */
#ifndef SOAP_TYPE__saml1__SubjectConfirmation
#define SOAP_TYPE__saml1__SubjectConfirmation (449)
typedef struct saml1__SubjectConfirmationType _saml1__SubjectConfirmation;
#endif

/* saml1.h:667 */
#ifndef SOAP_TYPE__saml1__SubjectConfirmationData
#define SOAP_TYPE__saml1__SubjectConfirmationData (450)
typedef _XML _saml1__SubjectConfirmationData;
#endif

/* saml1.h:670 */
#ifndef SOAP_TYPE__saml1__ConfirmationMethod
#define SOAP_TYPE__saml1__ConfirmationMethod (451)
typedef char *_saml1__ConfirmationMethod;
#endif

/* saml1.h:673 */
#ifndef SOAP_TYPE__saml1__AuthenticationStatement
#define SOAP_TYPE__saml1__AuthenticationStatement (452)
typedef struct saml1__AuthenticationStatementType _saml1__AuthenticationStatement;
#endif

/* saml1.h:676 */
#ifndef SOAP_TYPE__saml1__SubjectLocality
#define SOAP_TYPE__saml1__SubjectLocality (453)
typedef struct saml1__SubjectLocalityType _saml1__SubjectLocality;
#endif

/* saml1.h:679 */
#ifndef SOAP_TYPE__saml1__AuthorityBinding
#define SOAP_TYPE__saml1__AuthorityBinding (454)
typedef struct saml1__AuthorityBindingType _saml1__AuthorityBinding;
#endif

/* saml1.h:682 */
#ifndef SOAP_TYPE__saml1__AuthorizationDecisionStatement
#define SOAP_TYPE__saml1__AuthorizationDecisionStatement (455)
typedef struct saml1__AuthorizationDecisionStatementType _saml1__AuthorizationDecisionStatement;
#endif

/* saml1.h:685 */
#ifndef SOAP_TYPE__saml1__Action
#define SOAP_TYPE__saml1__Action (456)
typedef struct saml1__ActionType _saml1__Action;
#endif

/* saml1.h:688 */
#ifndef SOAP_TYPE__saml1__Evidence
#define SOAP_TYPE__saml1__Evidence (457)
typedef struct saml1__EvidenceType _saml1__Evidence;
#endif

/* saml1.h:691 */
#ifndef SOAP_TYPE__saml1__AttributeStatement
#define SOAP_TYPE__saml1__AttributeStatement (458)
typedef struct saml1__AttributeStatementType _saml1__AttributeStatement;
#endif

/* saml1.h:694 */
#ifndef SOAP_TYPE__saml1__AttributeDesignator
#define SOAP_TYPE__saml1__AttributeDesignator (459)
typedef struct saml1__AttributeDesignatorType _saml1__AttributeDesignator;
#endif

/* saml1.h:697 */
#ifndef SOAP_TYPE__saml1__Attribute
#define SOAP_TYPE__saml1__Attribute (460)
typedef struct saml1__AttributeType _saml1__Attribute;
#endif

/* saml1.h:700 */
#ifndef SOAP_TYPE__saml1__AttributeValue
#define SOAP_TYPE__saml1__AttributeValue (461)
typedef _XML _saml1__AttributeValue;
#endif

/* saml2.h:781 */
#ifndef SOAP_TYPE__saml2__BaseID
#define SOAP_TYPE__saml2__BaseID (520)
typedef struct saml2__BaseIDAbstractType _saml2__BaseID;
#endif

/* saml2.h:784 */
#ifndef SOAP_TYPE__saml2__NameID
#define SOAP_TYPE__saml2__NameID (521)
typedef struct saml2__NameIDType _saml2__NameID;
#endif

/* saml2.h:787 */
#ifndef SOAP_TYPE__saml2__EncryptedID
#define SOAP_TYPE__saml2__EncryptedID (522)
typedef struct saml2__EncryptedElementType _saml2__EncryptedID;
#endif

/* saml2.h:790 */
#ifndef SOAP_TYPE__saml2__Issuer
#define SOAP_TYPE__saml2__Issuer (523)
typedef struct saml2__NameIDType _saml2__Issuer;
#endif

/* saml2.h:793 */
#ifndef SOAP_TYPE__saml2__AssertionIDRef
#define SOAP_TYPE__saml2__AssertionIDRef (524)
typedef char *_saml2__AssertionIDRef;
#endif

/* saml2.h:796 */
#ifndef SOAP_TYPE__saml2__AssertionURIRef
#define SOAP_TYPE__saml2__AssertionURIRef (525)
typedef char *_saml2__AssertionURIRef;
#endif

/* saml2.h:799 */
#ifndef SOAP_TYPE__saml2__Assertion
#define SOAP_TYPE__saml2__Assertion (526)
typedef struct saml2__AssertionType _saml2__Assertion;
#endif

/* saml2.h:802 */
#ifndef SOAP_TYPE__saml2__Subject
#define SOAP_TYPE__saml2__Subject (527)
typedef struct saml2__SubjectType _saml2__Subject;
#endif

/* saml2.h:805 */
#ifndef SOAP_TYPE__saml2__SubjectConfirmation
#define SOAP_TYPE__saml2__SubjectConfirmation (528)
typedef struct saml2__SubjectConfirmationType _saml2__SubjectConfirmation;
#endif

/* saml2.h:808 */
#ifndef SOAP_TYPE__saml2__SubjectConfirmationData
#define SOAP_TYPE__saml2__SubjectConfirmationData (529)
typedef struct saml2__SubjectConfirmationDataType _saml2__SubjectConfirmationData;
#endif

/* saml2.h:811 */
#ifndef SOAP_TYPE__saml2__Conditions
#define SOAP_TYPE__saml2__Conditions (530)
typedef struct saml2__ConditionsType _saml2__Conditions;
#endif

/* saml2.h:814 */
#ifndef SOAP_TYPE__saml2__Condition
#define SOAP_TYPE__saml2__Condition (531)
typedef struct saml2__ConditionAbstractType _saml2__Condition;
#endif

/* saml2.h:817 */
#ifndef SOAP_TYPE__saml2__AudienceRestriction
#define SOAP_TYPE__saml2__AudienceRestriction (532)
typedef struct saml2__AudienceRestrictionType _saml2__AudienceRestriction;
#endif

/* saml2.h:820 */
#ifndef SOAP_TYPE__saml2__Audience
#define SOAP_TYPE__saml2__Audience (533)
typedef char *_saml2__Audience;
#endif

/* saml2.h:823 */
#ifndef SOAP_TYPE__saml2__OneTimeUse
#define SOAP_TYPE__saml2__OneTimeUse (534)
typedef struct saml2__OneTimeUseType _saml2__OneTimeUse;
#endif

/* saml2.h:826 */
#ifndef SOAP_TYPE__saml2__ProxyRestriction
#define SOAP_TYPE__saml2__ProxyRestriction (535)
typedef struct saml2__ProxyRestrictionType _saml2__ProxyRestriction;
#endif

/* saml2.h:829 */
#ifndef SOAP_TYPE__saml2__Advice
#define SOAP_TYPE__saml2__Advice (536)
typedef struct saml2__AdviceType _saml2__Advice;
#endif

/* saml2.h:832 */
#ifndef SOAP_TYPE__saml2__EncryptedAssertion
#define SOAP_TYPE__saml2__EncryptedAssertion (537)
typedef struct saml2__EncryptedElementType _saml2__EncryptedAssertion;
#endif

/* saml2.h:835 */
#ifndef SOAP_TYPE__saml2__Statement
#define SOAP_TYPE__saml2__Statement (538)
typedef struct saml2__StatementAbstractType _saml2__Statement;
#endif

/* saml2.h:838 */
#ifndef SOAP_TYPE__saml2__AuthnStatement
#define SOAP_TYPE__saml2__AuthnStatement (539)
typedef struct saml2__AuthnStatementType _saml2__AuthnStatement;
#endif

/* saml2.h:841 */
#ifndef SOAP_TYPE__saml2__SubjectLocality
#define SOAP_TYPE__saml2__SubjectLocality (540)
typedef struct saml2__SubjectLocalityType _saml2__SubjectLocality;
#endif

/* saml2.h:844 */
#ifndef SOAP_TYPE__saml2__AuthnContext
#define SOAP_TYPE__saml2__AuthnContext (541)
typedef struct saml2__AuthnContextType _saml2__AuthnContext;
#endif

/* saml2.h:847 */
#ifndef SOAP_TYPE__saml2__AuthnContextClassRef
#define SOAP_TYPE__saml2__AuthnContextClassRef (542)
typedef char *_saml2__AuthnContextClassRef;
#endif

/* saml2.h:850 */
#ifndef SOAP_TYPE__saml2__AuthnContextDeclRef
#define SOAP_TYPE__saml2__AuthnContextDeclRef (543)
typedef char *_saml2__AuthnContextDeclRef;
#endif

/* saml2.h:853 */
#ifndef SOAP_TYPE__saml2__AuthnContextDecl
#define SOAP_TYPE__saml2__AuthnContextDecl (544)
typedef _XML _saml2__AuthnContextDecl;
#endif

/* saml2.h:856 */
#ifndef SOAP_TYPE__saml2__AuthenticatingAuthority
#define SOAP_TYPE__saml2__AuthenticatingAuthority (545)
typedef char *_saml2__AuthenticatingAuthority;
#endif

/* saml2.h:859 */
#ifndef SOAP_TYPE__saml2__AuthzDecisionStatement
#define SOAP_TYPE__saml2__AuthzDecisionStatement (546)
typedef struct saml2__AuthzDecisionStatementType _saml2__AuthzDecisionStatement;
#endif

/* saml2.h:862 */
#ifndef SOAP_TYPE__saml2__Action
#define SOAP_TYPE__saml2__Action (547)
typedef struct saml2__ActionType _saml2__Action;
#endif

/* saml2.h:865 */
#ifndef SOAP_TYPE__saml2__Evidence
#define SOAP_TYPE__saml2__Evidence (548)
typedef struct saml2__EvidenceType _saml2__Evidence;
#endif

/* saml2.h:868 */
#ifndef SOAP_TYPE__saml2__AttributeStatement
#define SOAP_TYPE__saml2__AttributeStatement (549)
typedef struct saml2__AttributeStatementType _saml2__AttributeStatement;
#endif

/* saml2.h:871 */
#ifndef SOAP_TYPE__saml2__Attribute
#define SOAP_TYPE__saml2__Attribute (550)
typedef struct saml2__AttributeType _saml2__Attribute;
#endif

/* saml2.h:874 */
#ifndef SOAP_TYPE__saml2__AttributeValue
#define SOAP_TYPE__saml2__AttributeValue (551)
typedef _XML _saml2__AttributeValue;
#endif

/* saml2.h:877 */
#ifndef SOAP_TYPE__saml2__EncryptedAttribute
#define SOAP_TYPE__saml2__EncryptedAttribute (552)
typedef struct saml2__EncryptedElementType _saml2__EncryptedAttribute;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (303)
#endif

/* _wsa5__RetryAfter has binding name '_wsa5__RetryAfter' for type '' */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (36)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (35)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (155)
#endif

/* enum saml2__DecisionType has binding name 'saml2__DecisionType' for type 'saml2:DecisionType' */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (485)
#endif

/* enum saml1__DecisionType has binding name 'saml1__DecisionType' for type 'saml1:DecisionType' */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (406)
#endif

/* enum wsc__FaultCodeType has binding name 'wsc__FaultCodeType' for type 'wsc:FaultCodeType' */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (375)
#endif

/* enum wsse__FaultcodeEnum has binding name 'wsse__FaultcodeEnum' for type 'wsse:FaultcodeEnum' */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (298)
#endif

/* enum wsu__tTimestampFault has binding name 'wsu__tTimestampFault' for type 'wsu:tTimestampFault' */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (295)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (145)
#endif

/* enum _wsa5__IsReferenceParameter has binding name '_wsa5__IsReferenceParameter' for type 'wsa5:IsReferenceParameter' */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (40)
#endif

/* enum wsa5__FaultCodesType has binding name 'wsa5__FaultCodesType' for type 'wsa5:FaultCodesType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (20)
#endif

/* enum wsa5__RelationshipType has binding name 'wsa5__RelationshipType' for type 'wsa5:RelationshipType' */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (19)
#endif

/* _wstop__TopicNamespaceType_Topic has binding name '_wstop__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (181)
#endif

/* _wsnt__Subscribe_SubscriptionPolicy has binding name '_wsnt__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (176)
#endif

/* _wsnt__NotificationMessageHolderType_Message has binding name '_wsnt__NotificationMessageHolderType_Message' for type '' */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (172)
#endif

/* _wsrfbf__BaseFaultType_FaultCause has binding name '_wsrfbf__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (169)
#endif

/* _wsrfbf__BaseFaultType_Description has binding name '_wsrfbf__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (166)
#endif

/* _wsrfbf__BaseFaultType_ErrorCode has binding name '_wsrfbf__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (164)
#endif

/* _tev__CreatePullPointSubscription_SubscriptionPolicy has binding name '_tev__CreatePullPointSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy
#define SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy (153)
#endif

/* wstop__ConcreteTopicExpression has binding name 'wstop__ConcreteTopicExpression' for type 'wstop:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (143)
#endif

/* wsnt__AbsoluteOrRelativeTimeType has binding name 'wsnt__AbsoluteOrRelativeTimeType' for type 'wsnt:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (142)
#endif

/* wstop__TopicSetType has binding name 'wstop__TopicSetType' for type 'wstop:TopicSetType' */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (141)
#endif

/* wstop__TopicType has binding name 'wstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (140)
#endif

/* wstop__TopicNamespaceType has binding name 'wstop__TopicNamespaceType' for type 'wstop:TopicNamespaceType' */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (139)
#endif

/* wstop__QueryExpressionType has binding name 'wstop__QueryExpressionType' for type 'wstop:QueryExpressionType' */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (138)
#endif

/* wstop__ExtensibleDocumented has binding name 'wstop__ExtensibleDocumented' for type 'wstop:ExtensibleDocumented' */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (137)
#endif

/* wstop__Documentation has binding name 'wstop__Documentation' for type 'wstop:Documentation' */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (136)
#endif

/* _wsnt__ResumeSubscriptionResponse has binding name '_wsnt__ResumeSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (135)
#endif

/* _wsnt__ResumeSubscription has binding name '_wsnt__ResumeSubscription' for type '' */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (134)
#endif

/* _wsnt__PauseSubscriptionResponse has binding name '_wsnt__PauseSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (133)
#endif

/* _wsnt__PauseSubscription has binding name '_wsnt__PauseSubscription' for type '' */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (132)
#endif

/* _wsnt__UnsubscribeResponse has binding name '_wsnt__UnsubscribeResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (131)
#endif

/* _wsnt__Unsubscribe has binding name '_wsnt__Unsubscribe' for type '' */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (130)
#endif

/* _wsnt__RenewResponse has binding name '_wsnt__RenewResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (129)
#endif

/* _wsnt__Renew has binding name '_wsnt__Renew' for type '' */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (128)
#endif

/* _wsnt__CreatePullPointResponse has binding name '_wsnt__CreatePullPointResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (127)
#endif

/* _wsnt__CreatePullPoint has binding name '_wsnt__CreatePullPoint' for type '' */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (126)
#endif

/* _wsnt__DestroyPullPointResponse has binding name '_wsnt__DestroyPullPointResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (125)
#endif

/* _wsnt__DestroyPullPoint has binding name '_wsnt__DestroyPullPoint' for type '' */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (124)
#endif

/* _wsnt__GetMessagesResponse has binding name '_wsnt__GetMessagesResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (123)
#endif

/* _wsnt__GetMessages has binding name '_wsnt__GetMessages' for type '' */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (122)
#endif

/* _wsnt__GetCurrentMessageResponse has binding name '_wsnt__GetCurrentMessageResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (121)
#endif

/* _wsnt__GetCurrentMessage has binding name '_wsnt__GetCurrentMessage' for type '' */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (120)
#endif

/* _wsnt__SubscribeResponse has binding name '_wsnt__SubscribeResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (119)
#endif

/* _wsnt__Subscribe has binding name '_wsnt__Subscribe' for type '' */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (118)
#endif

/* _wsnt__UseRaw has binding name '_wsnt__UseRaw' for type '' */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (117)
#endif

/* _wsnt__Notify has binding name '_wsnt__Notify' for type '' */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (116)
#endif

/* _wsnt__SubscriptionManagerRP has binding name '_wsnt__SubscriptionManagerRP' for type '' */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (115)
#endif

/* _wsnt__NotificationProducerRP has binding name '_wsnt__NotificationProducerRP' for type '' */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (114)
#endif

/* wsnt__ResumeFailedFaultType has binding name 'wsnt__ResumeFailedFaultType' for type 'wsnt:ResumeFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (113)
#endif

/* wsnt__PauseFailedFaultType has binding name 'wsnt__PauseFailedFaultType' for type 'wsnt:PauseFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (112)
#endif

/* wsnt__UnableToDestroySubscriptionFaultType has binding name 'wsnt__UnableToDestroySubscriptionFaultType' for type 'wsnt:UnableToDestroySubscriptionFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (111)
#endif

/* wsnt__UnacceptableTerminationTimeFaultType has binding name 'wsnt__UnacceptableTerminationTimeFaultType' for type 'wsnt:UnacceptableTerminationTimeFaultType' */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (110)
#endif

/* wsnt__UnableToCreatePullPointFaultType has binding name 'wsnt__UnableToCreatePullPointFaultType' for type 'wsnt:UnableToCreatePullPointFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (109)
#endif

/* wsnt__UnableToDestroyPullPointFaultType has binding name 'wsnt__UnableToDestroyPullPointFaultType' for type 'wsnt:UnableToDestroyPullPointFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (108)
#endif

/* wsnt__UnableToGetMessagesFaultType has binding name 'wsnt__UnableToGetMessagesFaultType' for type 'wsnt:UnableToGetMessagesFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (107)
#endif

/* wsnt__NoCurrentMessageOnTopicFaultType has binding name 'wsnt__NoCurrentMessageOnTopicFaultType' for type 'wsnt:NoCurrentMessageOnTopicFaultType' */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (106)
#endif

/* wsnt__UnacceptableInitialTerminationTimeFaultType has binding name 'wsnt__UnacceptableInitialTerminationTimeFaultType' for type 'wsnt:UnacceptableInitialTerminationTimeFaultType' */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (105)
#endif

/* wsnt__NotifyMessageNotSupportedFaultType has binding name 'wsnt__NotifyMessageNotSupportedFaultType' for type 'wsnt:NotifyMessageNotSupportedFaultType' */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (104)
#endif

/* wsnt__UnsupportedPolicyRequestFaultType has binding name 'wsnt__UnsupportedPolicyRequestFaultType' for type 'wsnt:UnsupportedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (103)
#endif

/* wsnt__UnrecognizedPolicyRequestFaultType has binding name 'wsnt__UnrecognizedPolicyRequestFaultType' for type 'wsnt:UnrecognizedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (102)
#endif

/* wsnt__InvalidMessageContentExpressionFaultType has binding name 'wsnt__InvalidMessageContentExpressionFaultType' for type 'wsnt:InvalidMessageContentExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (101)
#endif

/* wsnt__InvalidProducerPropertiesExpressionFaultType has binding name 'wsnt__InvalidProducerPropertiesExpressionFaultType' for type 'wsnt:InvalidProducerPropertiesExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (100)
#endif

/* wsnt__MultipleTopicsSpecifiedFaultType has binding name 'wsnt__MultipleTopicsSpecifiedFaultType' for type 'wsnt:MultipleTopicsSpecifiedFaultType' */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (99)
#endif

/* wsnt__TopicNotSupportedFaultType has binding name 'wsnt__TopicNotSupportedFaultType' for type 'wsnt:TopicNotSupportedFaultType' */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (98)
#endif

/* wsnt__InvalidTopicExpressionFaultType has binding name 'wsnt__InvalidTopicExpressionFaultType' for type 'wsnt:InvalidTopicExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (97)
#endif

/* wsnt__TopicExpressionDialectUnknownFaultType has binding name 'wsnt__TopicExpressionDialectUnknownFaultType' for type 'wsnt:TopicExpressionDialectUnknownFaultType' */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (96)
#endif

/* wsnt__InvalidFilterFaultType has binding name 'wsnt__InvalidFilterFaultType' for type 'wsnt:InvalidFilterFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (95)
#endif

/* wsnt__SubscribeCreationFailedFaultType has binding name 'wsnt__SubscribeCreationFailedFaultType' for type 'wsnt:SubscribeCreationFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (94)
#endif

/* wsnt__NotificationMessageHolderType has binding name 'wsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (93)
#endif

/* wsnt__SubscriptionPolicyType has binding name 'wsnt__SubscriptionPolicyType' for type 'wsnt:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (92)
#endif

/* wsnt__FilterType has binding name 'wsnt__FilterType' for type 'wsnt:FilterType' */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (91)
#endif

/* wsnt__TopicExpressionType has binding name 'wsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (90)
#endif

/* wsnt__QueryExpressionType has binding name 'wsnt__QueryExpressionType' for type 'wsnt:QueryExpressionType' */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (89)
#endif

/* wsrfbf__BaseFaultType has binding name 'wsrfbf__BaseFaultType' for type 'wsrfbf:BaseFaultType' */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (88)
#endif

/* wsrfr__ResourceUnavailableFaultType has binding name 'wsrfr__ResourceUnavailableFaultType' for type 'wsrfr:ResourceUnavailableFaultType' */
#ifndef SOAP_TYPE_wsrfr__ResourceUnavailableFaultType
#define SOAP_TYPE_wsrfr__ResourceUnavailableFaultType (87)
#endif

/* wsrfr__ResourceUnknownFaultType has binding name 'wsrfr__ResourceUnknownFaultType' for type 'wsrfr:ResourceUnknownFaultType' */
#ifndef SOAP_TYPE_wsrfr__ResourceUnknownFaultType
#define SOAP_TYPE_wsrfr__ResourceUnknownFaultType (86)
#endif

/* _tev__GetEventBrokersResponse has binding name '_tev__GetEventBrokersResponse' for type '' */
#ifndef SOAP_TYPE__tev__GetEventBrokersResponse
#define SOAP_TYPE__tev__GetEventBrokersResponse (85)
#endif

/* _tev__GetEventBrokers has binding name '_tev__GetEventBrokers' for type '' */
#ifndef SOAP_TYPE__tev__GetEventBrokers
#define SOAP_TYPE__tev__GetEventBrokers (84)
#endif

/* _tev__DeleteEventBrokerResponse has binding name '_tev__DeleteEventBrokerResponse' for type '' */
#ifndef SOAP_TYPE__tev__DeleteEventBrokerResponse
#define SOAP_TYPE__tev__DeleteEventBrokerResponse (83)
#endif

/* _tev__DeleteEventBroker has binding name '_tev__DeleteEventBroker' for type '' */
#ifndef SOAP_TYPE__tev__DeleteEventBroker
#define SOAP_TYPE__tev__DeleteEventBroker (82)
#endif

/* _tev__AddEventBrokerResponse has binding name '_tev__AddEventBrokerResponse' for type '' */
#ifndef SOAP_TYPE__tev__AddEventBrokerResponse
#define SOAP_TYPE__tev__AddEventBrokerResponse (81)
#endif

/* _tev__AddEventBroker has binding name '_tev__AddEventBroker' for type '' */
#ifndef SOAP_TYPE__tev__AddEventBroker
#define SOAP_TYPE__tev__AddEventBroker (80)
#endif

/* _tev__GetEventPropertiesResponse has binding name '_tev__GetEventPropertiesResponse' for type '' */
#ifndef SOAP_TYPE__tev__GetEventPropertiesResponse
#define SOAP_TYPE__tev__GetEventPropertiesResponse (79)
#endif

/* _tev__GetEventProperties has binding name '_tev__GetEventProperties' for type '' */
#ifndef SOAP_TYPE__tev__GetEventProperties
#define SOAP_TYPE__tev__GetEventProperties (78)
#endif

/* _tev__SetSynchronizationPointResponse has binding name '_tev__SetSynchronizationPointResponse' for type '' */
#ifndef SOAP_TYPE__tev__SetSynchronizationPointResponse
#define SOAP_TYPE__tev__SetSynchronizationPointResponse (77)
#endif

/* _tev__SetSynchronizationPoint has binding name '_tev__SetSynchronizationPoint' for type '' */
#ifndef SOAP_TYPE__tev__SetSynchronizationPoint
#define SOAP_TYPE__tev__SetSynchronizationPoint (76)
#endif

/* _tev__SeekResponse has binding name '_tev__SeekResponse' for type '' */
#ifndef SOAP_TYPE__tev__SeekResponse
#define SOAP_TYPE__tev__SeekResponse (75)
#endif

/* _tev__Seek has binding name '_tev__Seek' for type '' */
#ifndef SOAP_TYPE__tev__Seek
#define SOAP_TYPE__tev__Seek (74)
#endif

/* _tev__PullMessagesFaultResponse has binding name '_tev__PullMessagesFaultResponse' for type '' */
#ifndef SOAP_TYPE__tev__PullMessagesFaultResponse
#define SOAP_TYPE__tev__PullMessagesFaultResponse (73)
#endif

/* _tev__PullMessagesResponse has binding name '_tev__PullMessagesResponse' for type '' */
#ifndef SOAP_TYPE__tev__PullMessagesResponse
#define SOAP_TYPE__tev__PullMessagesResponse (72)
#endif

/* _tev__PullMessages has binding name '_tev__PullMessages' for type '' */
#ifndef SOAP_TYPE__tev__PullMessages
#define SOAP_TYPE__tev__PullMessages (71)
#endif

/* _tev__CreatePullPointSubscriptionResponse has binding name '_tev__CreatePullPointSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscriptionResponse
#define SOAP_TYPE__tev__CreatePullPointSubscriptionResponse (70)
#endif

/* _tev__CreatePullPointSubscription has binding name '_tev__CreatePullPointSubscription' for type '' */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription
#define SOAP_TYPE__tev__CreatePullPointSubscription (69)
#endif

/* _tev__GetServiceCapabilitiesResponse has binding name '_tev__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__tev__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tev__GetServiceCapabilitiesResponse (68)
#endif

/* _tev__GetServiceCapabilities has binding name '_tev__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__tev__GetServiceCapabilities
#define SOAP_TYPE__tev__GetServiceCapabilities (67)
#endif

/* tev__EventBrokerConfig has binding name 'tev__EventBrokerConfig' for type 'tev:EventBrokerConfig' */
#ifndef SOAP_TYPE_tev__EventBrokerConfig
#define SOAP_TYPE_tev__EventBrokerConfig (66)
#endif

/* tev__Capabilities has binding name 'tev__Capabilities' for type 'tev:Capabilities' */
#ifndef SOAP_TYPE_tev__Capabilities
#define SOAP_TYPE_tev__Capabilities (65)
#endif

/* _xml__lang has binding name '_xml__lang' for type '' */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (64)
#endif

/* xsd__token has binding name 'xsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (63)
#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (62)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (61)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (60)
#endif

/* xsd__NCName has binding name 'xsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (59)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (58)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (57)
#endif

/* struct _wsse__Security has binding name '_wsse__Security' for type '' */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (553)
#endif

/* _saml2__EncryptedAttribute has binding name '_saml2__EncryptedAttribute' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedAttribute
#define SOAP_TYPE__saml2__EncryptedAttribute (552)
#endif

/* _saml2__Attribute has binding name '_saml2__Attribute' for type '' */
#ifndef SOAP_TYPE__saml2__Attribute
#define SOAP_TYPE__saml2__Attribute (550)
#endif

/* _saml2__AttributeStatement has binding name '_saml2__AttributeStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AttributeStatement
#define SOAP_TYPE__saml2__AttributeStatement (549)
#endif

/* _saml2__Evidence has binding name '_saml2__Evidence' for type '' */
#ifndef SOAP_TYPE__saml2__Evidence
#define SOAP_TYPE__saml2__Evidence (548)
#endif

/* _saml2__Action has binding name '_saml2__Action' for type '' */
#ifndef SOAP_TYPE__saml2__Action
#define SOAP_TYPE__saml2__Action (547)
#endif

/* _saml2__AuthzDecisionStatement has binding name '_saml2__AuthzDecisionStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AuthzDecisionStatement
#define SOAP_TYPE__saml2__AuthzDecisionStatement (546)
#endif

/* _saml2__AuthnContext has binding name '_saml2__AuthnContext' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContext
#define SOAP_TYPE__saml2__AuthnContext (541)
#endif

/* _saml2__SubjectLocality has binding name '_saml2__SubjectLocality' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectLocality
#define SOAP_TYPE__saml2__SubjectLocality (540)
#endif

/* _saml2__AuthnStatement has binding name '_saml2__AuthnStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnStatement
#define SOAP_TYPE__saml2__AuthnStatement (539)
#endif

/* _saml2__Statement has binding name '_saml2__Statement' for type '' */
#ifndef SOAP_TYPE__saml2__Statement
#define SOAP_TYPE__saml2__Statement (538)
#endif

/* _saml2__EncryptedAssertion has binding name '_saml2__EncryptedAssertion' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedAssertion
#define SOAP_TYPE__saml2__EncryptedAssertion (537)
#endif

/* _saml2__Advice has binding name '_saml2__Advice' for type '' */
#ifndef SOAP_TYPE__saml2__Advice
#define SOAP_TYPE__saml2__Advice (536)
#endif

/* _saml2__ProxyRestriction has binding name '_saml2__ProxyRestriction' for type '' */
#ifndef SOAP_TYPE__saml2__ProxyRestriction
#define SOAP_TYPE__saml2__ProxyRestriction (535)
#endif

/* _saml2__OneTimeUse has binding name '_saml2__OneTimeUse' for type '' */
#ifndef SOAP_TYPE__saml2__OneTimeUse
#define SOAP_TYPE__saml2__OneTimeUse (534)
#endif

/* _saml2__AudienceRestriction has binding name '_saml2__AudienceRestriction' for type '' */
#ifndef SOAP_TYPE__saml2__AudienceRestriction
#define SOAP_TYPE__saml2__AudienceRestriction (532)
#endif

/* _saml2__Condition has binding name '_saml2__Condition' for type '' */
#ifndef SOAP_TYPE__saml2__Condition
#define SOAP_TYPE__saml2__Condition (531)
#endif

/* _saml2__Conditions has binding name '_saml2__Conditions' for type '' */
#ifndef SOAP_TYPE__saml2__Conditions
#define SOAP_TYPE__saml2__Conditions (530)
#endif

/* _saml2__SubjectConfirmationData has binding name '_saml2__SubjectConfirmationData' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectConfirmationData
#define SOAP_TYPE__saml2__SubjectConfirmationData (529)
#endif

/* _saml2__SubjectConfirmation has binding name '_saml2__SubjectConfirmation' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectConfirmation
#define SOAP_TYPE__saml2__SubjectConfirmation (528)
#endif

/* _saml2__Subject has binding name '_saml2__Subject' for type '' */
#ifndef SOAP_TYPE__saml2__Subject
#define SOAP_TYPE__saml2__Subject (527)
#endif

/* _saml2__Assertion has binding name '_saml2__Assertion' for type '' */
#ifndef SOAP_TYPE__saml2__Assertion
#define SOAP_TYPE__saml2__Assertion (526)
#endif

/* _saml2__Issuer has binding name '_saml2__Issuer' for type '' */
#ifndef SOAP_TYPE__saml2__Issuer
#define SOAP_TYPE__saml2__Issuer (523)
#endif

/* _saml2__EncryptedID has binding name '_saml2__EncryptedID' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedID
#define SOAP_TYPE__saml2__EncryptedID (522)
#endif

/* _saml2__NameID has binding name '_saml2__NameID' for type '' */
#ifndef SOAP_TYPE__saml2__NameID
#define SOAP_TYPE__saml2__NameID (521)
#endif

/* _saml2__BaseID has binding name '_saml2__BaseID' for type '' */
#ifndef SOAP_TYPE__saml2__BaseID
#define SOAP_TYPE__saml2__BaseID (520)
#endif

/* struct saml2__AttributeType has binding name 'saml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (484)
#endif

/* struct saml2__AttributeStatementType has binding name 'saml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (483)
#endif

/* struct saml2__EvidenceType has binding name 'saml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (482)
#endif

/* struct saml2__ActionType has binding name 'saml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (481)
#endif

/* struct saml2__AuthzDecisionStatementType has binding name 'saml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (480)
#endif

/* struct saml2__AuthnContextType has binding name 'saml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (479)
#endif

/* struct saml2__SubjectLocalityType has binding name 'saml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (478)
#endif

/* struct saml2__AuthnStatementType has binding name 'saml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (477)
#endif

/* struct saml2__StatementAbstractType has binding name 'saml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (476)
#endif

/* struct saml2__AdviceType has binding name 'saml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (475)
#endif

/* struct saml2__ProxyRestrictionType has binding name 'saml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (474)
#endif

/* struct saml2__OneTimeUseType has binding name 'saml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (473)
#endif

/* struct saml2__AudienceRestrictionType has binding name 'saml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (472)
#endif

/* struct saml2__ConditionAbstractType has binding name 'saml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (471)
#endif

/* struct saml2__ConditionsType has binding name 'saml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (470)
#endif

/* struct saml2__KeyInfoConfirmationDataType has binding name 'saml2__KeyInfoConfirmationDataType' for type 'saml2:KeyInfoConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (469)
#endif

/* struct saml2__SubjectConfirmationDataType has binding name 'saml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (468)
#endif

/* struct saml2__SubjectConfirmationType has binding name 'saml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (467)
#endif

/* struct saml2__SubjectType has binding name 'saml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (466)
#endif

/* struct saml2__AssertionType has binding name 'saml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (465)
#endif

/* struct saml2__EncryptedElementType has binding name 'saml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (464)
#endif

/* struct saml2__NameIDType has binding name 'saml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (463)
#endif

/* struct saml2__BaseIDAbstractType has binding name 'saml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (462)
#endif

/* _saml1__Attribute has binding name '_saml1__Attribute' for type '' */
#ifndef SOAP_TYPE__saml1__Attribute
#define SOAP_TYPE__saml1__Attribute (460)
#endif

/* _saml1__AttributeDesignator has binding name '_saml1__AttributeDesignator' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeDesignator
#define SOAP_TYPE__saml1__AttributeDesignator (459)
#endif

/* _saml1__AttributeStatement has binding name '_saml1__AttributeStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeStatement
#define SOAP_TYPE__saml1__AttributeStatement (458)
#endif

/* _saml1__Evidence has binding name '_saml1__Evidence' for type '' */
#ifndef SOAP_TYPE__saml1__Evidence
#define SOAP_TYPE__saml1__Evidence (457)
#endif

/* _saml1__Action has binding name '_saml1__Action' for type '' */
#ifndef SOAP_TYPE__saml1__Action
#define SOAP_TYPE__saml1__Action (456)
#endif

/* _saml1__AuthorizationDecisionStatement has binding name '_saml1__AuthorizationDecisionStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AuthorizationDecisionStatement
#define SOAP_TYPE__saml1__AuthorizationDecisionStatement (455)
#endif

/* _saml1__AuthorityBinding has binding name '_saml1__AuthorityBinding' for type '' */
#ifndef SOAP_TYPE__saml1__AuthorityBinding
#define SOAP_TYPE__saml1__AuthorityBinding (454)
#endif

/* _saml1__SubjectLocality has binding name '_saml1__SubjectLocality' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectLocality
#define SOAP_TYPE__saml1__SubjectLocality (453)
#endif

/* _saml1__AuthenticationStatement has binding name '_saml1__AuthenticationStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AuthenticationStatement
#define SOAP_TYPE__saml1__AuthenticationStatement (452)
#endif

/* _saml1__SubjectConfirmation has binding name '_saml1__SubjectConfirmation' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectConfirmation
#define SOAP_TYPE__saml1__SubjectConfirmation (449)
#endif

/* _saml1__NameIdentifier has binding name '_saml1__NameIdentifier' for type '' */
#ifndef SOAP_TYPE__saml1__NameIdentifier
#define SOAP_TYPE__saml1__NameIdentifier (448)
#endif

/* _saml1__Subject has binding name '_saml1__Subject' for type '' */
#ifndef SOAP_TYPE__saml1__Subject
#define SOAP_TYPE__saml1__Subject (447)
#endif

/* _saml1__SubjectStatement has binding name '_saml1__SubjectStatement' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectStatement
#define SOAP_TYPE__saml1__SubjectStatement (446)
#endif

/* _saml1__Statement has binding name '_saml1__Statement' for type '' */
#ifndef SOAP_TYPE__saml1__Statement
#define SOAP_TYPE__saml1__Statement (445)
#endif

/* _saml1__Advice has binding name '_saml1__Advice' for type '' */
#ifndef SOAP_TYPE__saml1__Advice
#define SOAP_TYPE__saml1__Advice (444)
#endif

/* _saml1__DoNotCacheCondition has binding name '_saml1__DoNotCacheCondition' for type '' */
#ifndef SOAP_TYPE__saml1__DoNotCacheCondition
#define SOAP_TYPE__saml1__DoNotCacheCondition (443)
#endif

/* _saml1__AudienceRestrictionCondition has binding name '_saml1__AudienceRestrictionCondition' for type '' */
#ifndef SOAP_TYPE__saml1__AudienceRestrictionCondition
#define SOAP_TYPE__saml1__AudienceRestrictionCondition (441)
#endif

/* _saml1__Condition has binding name '_saml1__Condition' for type '' */
#ifndef SOAP_TYPE__saml1__Condition
#define SOAP_TYPE__saml1__Condition (440)
#endif

/* _saml1__Conditions has binding name '_saml1__Conditions' for type '' */
#ifndef SOAP_TYPE__saml1__Conditions
#define SOAP_TYPE__saml1__Conditions (439)
#endif

/* _saml1__Assertion has binding name '_saml1__Assertion' for type '' */
#ifndef SOAP_TYPE__saml1__Assertion
#define SOAP_TYPE__saml1__Assertion (438)
#endif

/* struct saml1__AttributeType has binding name 'saml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (405)
#endif

/* struct saml1__AttributeDesignatorType has binding name 'saml1__AttributeDesignatorType' for type 'saml1:AttributeDesignatorType' */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (404)
#endif

/* struct saml1__AttributeStatementType has binding name 'saml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (403)
#endif

/* struct saml1__EvidenceType has binding name 'saml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (402)
#endif

/* struct saml1__ActionType has binding name 'saml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (401)
#endif

/* struct saml1__AuthorizationDecisionStatementType has binding name 'saml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (400)
#endif

/* struct saml1__AuthorityBindingType has binding name 'saml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (399)
#endif

/* struct saml1__SubjectLocalityType has binding name 'saml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (398)
#endif

/* struct saml1__AuthenticationStatementType has binding name 'saml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (397)
#endif

/* struct saml1__SubjectConfirmationType has binding name 'saml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (396)
#endif

/* struct saml1__NameIdentifierType has binding name 'saml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (395)
#endif

/* struct saml1__SubjectType has binding name 'saml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (394)
#endif

/* struct saml1__SubjectStatementAbstractType has binding name 'saml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (393)
#endif

/* struct saml1__StatementAbstractType has binding name 'saml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (392)
#endif

/* struct saml1__AdviceType has binding name 'saml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (391)
#endif

/* struct saml1__DoNotCacheConditionType has binding name 'saml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (390)
#endif

/* struct saml1__AudienceRestrictionConditionType has binding name 'saml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (389)
#endif

/* struct saml1__ConditionAbstractType has binding name 'saml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (388)
#endif

/* struct saml1__ConditionsType has binding name 'saml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (387)
#endif

/* struct saml1__AssertionType has binding name 'saml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (386)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (385)
#endif

/* struct wsc__PropertiesType has binding name 'wsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (378)
#endif

/* struct wsc__DerivedKeyTokenType has binding name 'wsc__DerivedKeyTokenType' for type 'wsc:DerivedKeyTokenType' */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (377)
#endif

/* struct wsc__SecurityContextTokenType has binding name 'wsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (376)
#endif

/* struct _xenc__ReferenceList has binding name '_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (362)
#endif

/* struct xenc__EncryptionPropertyType has binding name 'xenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (361)
#endif

/* struct xenc__EncryptionPropertiesType has binding name 'xenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (360)
#endif

/* struct xenc__ReferenceType has binding name 'xenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (359)
#endif

/* struct xenc__AgreementMethodType has binding name 'xenc__AgreementMethodType' for type 'xenc:AgreementMethodType' */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (358)
#endif

/* struct xenc__EncryptedDataType has binding name 'xenc__EncryptedDataType' for type 'xenc:EncryptedDataType' */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (357)
#endif

/* struct xenc__TransformsType has binding name 'xenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (356)
#endif

/* struct xenc__CipherReferenceType has binding name 'xenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (355)
#endif

/* struct xenc__CipherDataType has binding name 'xenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (354)
#endif

/* struct xenc__EncryptionMethodType has binding name 'xenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (353)
#endif

/* struct xenc__EncryptedType has binding name 'xenc__EncryptedType' for type 'xenc:EncryptedType' */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (352)
#endif

/* struct ds__RSAKeyValueType has binding name 'ds__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (341)
#endif

/* struct ds__DSAKeyValueType has binding name 'ds__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (340)
#endif

/* struct ds__X509IssuerSerialType has binding name 'ds__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (339)
#endif

/* _ds__KeyInfo has binding name '_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (338)
#endif

/* struct ds__RetrievalMethodType has binding name 'ds__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (335)
#endif

/* struct ds__KeyValueType has binding name 'ds__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (333)
#endif

/* struct ds__DigestMethodType has binding name 'ds__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (332)
#endif

/* _ds__Transform has binding name '_ds__Transform' for type '' */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (331)
#endif

/* struct ds__TransformType has binding name 'ds__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (329)
#endif

/* struct _c14n__InclusiveNamespaces has binding name '_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (328)
#endif

/* struct ds__TransformsType has binding name 'ds__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (327)
#endif

/* struct ds__ReferenceType has binding name 'ds__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (326)
#endif

/* struct ds__SignatureMethodType has binding name 'ds__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (325)
#endif

/* struct ds__CanonicalizationMethodType has binding name 'ds__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (324)
#endif

/* _ds__Signature has binding name '_ds__Signature' for type '' */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (323)
#endif

/* struct ds__SignedInfoType has binding name 'ds__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (320)
#endif

/* struct ds__SignatureType has binding name 'ds__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (319)
#endif

/* struct xenc__EncryptedKeyType has binding name 'xenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (316)
#endif

/* struct ds__KeyInfoType has binding name 'ds__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (315)
#endif

/* struct ds__X509DataType has binding name 'ds__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (313)
#endif

/* struct _wsse__SecurityTokenReference has binding name '_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (309)
#endif

/* struct _wsse__KeyIdentifier has binding name '_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (308)
#endif

/* struct _wsse__Embedded has binding name '_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (307)
#endif

/* struct _wsse__Reference has binding name '_wsse__Reference' for type '' */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (306)
#endif

/* struct _wsse__BinarySecurityToken has binding name '_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (305)
#endif

/* struct _wsse__Password has binding name '_wsse__Password' for type '' */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (300)
#endif

/* struct _wsse__UsernameToken has binding name '_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (299)
#endif

/* struct wsse__EncodedString has binding name 'wsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (297)
#endif

/* struct _wsu__Timestamp has binding name '_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (296)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (56)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (52)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (50)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (48)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (42)
#endif

/* struct chan__ChannelInstanceType has binding name 'chan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (41)
#endif

/* _wsa5__ProblemAction has binding name '_wsa5__ProblemAction' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (39)
#endif

/* _wsa5__FaultTo has binding name '_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (32)
#endif

/* _wsa5__From has binding name '_wsa5__From' for type '' */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (31)
#endif

/* _wsa5__ReplyTo has binding name '_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (30)
#endif

/* _wsa5__RelatesTo has binding name '_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (29)
#endif

/* _wsa5__Metadata has binding name '_wsa5__Metadata' for type '' */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (27)
#endif

/* _wsa5__ReferenceParameters has binding name '_wsa5__ReferenceParameters' for type '' */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (26)
#endif

/* _wsa5__EndpointReference has binding name '_wsa5__EndpointReference' for type '' */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (25)
#endif

/* struct wsa5__ProblemActionType has binding name 'wsa5__ProblemActionType' for type 'wsa5:ProblemActionType' */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (16)
#endif

/* struct wsa5__RelatesToType has binding name 'wsa5__RelatesToType' for type 'wsa5:RelatesToType' */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (15)
#endif

/* struct wsa5__MetadataType has binding name 'wsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (14)
#endif

/* struct wsa5__ReferenceParametersType has binding name 'wsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (13)
#endif

/* struct wsa5__EndpointReferenceType has binding name 'wsa5__EndpointReferenceType' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (12)
#endif

/* xsd__anyAttribute has binding name 'xsd__anyAttribute' for type 'xsd:anyAttribute' */
#ifndef SOAP_TYPE_xsd__anyAttribute
#define SOAP_TYPE_xsd__anyAttribute (11)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (9)
#endif

/* struct _wsse__Security * has binding name 'PointerTo_wsse__Security' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Security
#define SOAP_TYPE_PointerTo_wsse__Security (559)
#endif

/* struct ds__SignatureType * has binding name 'PointerTods__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_PointerTods__SignatureType
#define SOAP_TYPE_PointerTods__SignatureType (558)
#endif

/* struct wsc__SecurityContextTokenType * has binding name 'PointerTowsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_PointerTowsc__SecurityContextTokenType
#define SOAP_TYPE_PointerTowsc__SecurityContextTokenType (557)
#endif

/* struct _wsse__BinarySecurityToken * has binding name 'PointerTo_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__BinarySecurityToken
#define SOAP_TYPE_PointerTo_wsse__BinarySecurityToken (556)
#endif

/* struct _wsse__UsernameToken * has binding name 'PointerTo_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__UsernameToken
#define SOAP_TYPE_PointerTo_wsse__UsernameToken (555)
#endif

/* struct _wsu__Timestamp * has binding name 'PointerTo_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsu__Timestamp
#define SOAP_TYPE_PointerTo_wsu__Timestamp (554)
#endif

/* _saml2__AttributeValue has binding name '_saml2__AttributeValue' for type '' */
#ifndef SOAP_TYPE__saml2__AttributeValue
#define SOAP_TYPE__saml2__AttributeValue (551)
#endif

/* _saml2__AuthenticatingAuthority has binding name '_saml2__AuthenticatingAuthority' for type '' */
#ifndef SOAP_TYPE__saml2__AuthenticatingAuthority
#define SOAP_TYPE__saml2__AuthenticatingAuthority (545)
#endif

/* _saml2__AuthnContextDecl has binding name '_saml2__AuthnContextDecl' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextDecl
#define SOAP_TYPE__saml2__AuthnContextDecl (544)
#endif

/* _saml2__AuthnContextDeclRef has binding name '_saml2__AuthnContextDeclRef' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextDeclRef
#define SOAP_TYPE__saml2__AuthnContextDeclRef (543)
#endif

/* _saml2__AuthnContextClassRef has binding name '_saml2__AuthnContextClassRef' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextClassRef
#define SOAP_TYPE__saml2__AuthnContextClassRef (542)
#endif

/* _saml2__Audience has binding name '_saml2__Audience' for type '' */
#ifndef SOAP_TYPE__saml2__Audience
#define SOAP_TYPE__saml2__Audience (533)
#endif

/* _saml2__AssertionURIRef has binding name '_saml2__AssertionURIRef' for type '' */
#ifndef SOAP_TYPE__saml2__AssertionURIRef
#define SOAP_TYPE__saml2__AssertionURIRef (525)
#endif

/* _saml2__AssertionIDRef has binding name '_saml2__AssertionIDRef' for type '' */
#ifndef SOAP_TYPE__saml2__AssertionIDRef
#define SOAP_TYPE__saml2__AssertionIDRef (524)
#endif

/* struct ds__KeyInfoType ** has binding name 'PointerToPointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerToPointerTo_ds__KeyInfo (519)
#endif

/* struct __saml2__union_AttributeStatementType * has binding name 'PointerTo__saml2__union_AttributeStatementType' for type '-saml2:union-AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType
#define SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType (518)
#endif

/* struct saml2__AttributeType * has binding name 'PointerTosaml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeType
#define SOAP_TYPE_PointerTosaml2__AttributeType (517)
#endif

/* struct saml2__EvidenceType * has binding name 'PointerTosaml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml2__EvidenceType
#define SOAP_TYPE_PointerTosaml2__EvidenceType (515)
#endif

/* struct saml2__ActionType * has binding name 'PointerTosaml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ActionType
#define SOAP_TYPE_PointerTosaml2__ActionType (514)
#endif

/* struct saml2__AuthnContextType * has binding name 'PointerTosaml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnContextType
#define SOAP_TYPE_PointerTosaml2__AuthnContextType (513)
#endif

/* struct saml2__SubjectLocalityType * has binding name 'PointerTosaml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml2__SubjectLocalityType (512)
#endif

/* struct __saml2__union_EvidenceType * has binding name 'PointerTo__saml2__union_EvidenceType' for type '-saml2:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml2__union_EvidenceType (511)
#endif

/* struct __saml2__union_AdviceType * has binding name 'PointerTo__saml2__union_AdviceType' for type '-saml2:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AdviceType
#define SOAP_TYPE_PointerTo__saml2__union_AdviceType (509)
#endif

/* struct saml2__AssertionType * has binding name 'PointerTosaml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AssertionType
#define SOAP_TYPE_PointerTosaml2__AssertionType (508)
#endif

/* struct __saml2__union_ConditionsType * has binding name 'PointerTo__saml2__union_ConditionsType' for type '-saml2:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml2__union_ConditionsType (506)
#endif

/* struct saml2__ProxyRestrictionType * has binding name 'PointerTosaml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ProxyRestrictionType
#define SOAP_TYPE_PointerTosaml2__ProxyRestrictionType (505)
#endif

/* struct saml2__OneTimeUseType * has binding name 'PointerTosaml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_PointerTosaml2__OneTimeUseType
#define SOAP_TYPE_PointerTosaml2__OneTimeUseType (504)
#endif

/* struct saml2__AudienceRestrictionType * has binding name 'PointerTosaml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AudienceRestrictionType
#define SOAP_TYPE_PointerTosaml2__AudienceRestrictionType (503)
#endif

/* struct saml2__ConditionAbstractType * has binding name 'PointerTosaml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml2__ConditionAbstractType (502)
#endif

/* struct saml2__SubjectConfirmationDataType * has binding name 'PointerTosaml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType (500)
#endif

/* struct saml2__SubjectConfirmationType * has binding name 'PointerTosaml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationType (499)
#endif

/* struct saml2__EncryptedElementType * has binding name 'PointerTosaml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_PointerTosaml2__EncryptedElementType
#define SOAP_TYPE_PointerTosaml2__EncryptedElementType (498)
#endif

/* struct saml2__BaseIDAbstractType * has binding name 'PointerTosaml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__BaseIDAbstractType
#define SOAP_TYPE_PointerTosaml2__BaseIDAbstractType (497)
#endif

/* struct __saml2__union_AssertionType * has binding name 'PointerTo__saml2__union_AssertionType' for type '-saml2:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AssertionType
#define SOAP_TYPE_PointerTo__saml2__union_AssertionType (496)
#endif

/* struct saml2__AttributeStatementType * has binding name 'PointerTosaml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeStatementType
#define SOAP_TYPE_PointerTosaml2__AttributeStatementType (495)
#endif

/* struct saml2__AuthzDecisionStatementType * has binding name 'PointerTosaml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType
#define SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType (494)
#endif

/* struct saml2__AuthnStatementType * has binding name 'PointerTosaml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnStatementType
#define SOAP_TYPE_PointerTosaml2__AuthnStatementType (493)
#endif

/* struct saml2__StatementAbstractType * has binding name 'PointerTosaml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__StatementAbstractType
#define SOAP_TYPE_PointerTosaml2__StatementAbstractType (492)
#endif

/* struct saml2__AdviceType * has binding name 'PointerTosaml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml2__AdviceType
#define SOAP_TYPE_PointerTosaml2__AdviceType (490)
#endif

/* struct saml2__ConditionsType * has binding name 'PointerTosaml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionsType
#define SOAP_TYPE_PointerTosaml2__ConditionsType (489)
#endif

/* struct saml2__SubjectType * has binding name 'PointerTosaml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectType
#define SOAP_TYPE_PointerTosaml2__SubjectType (488)
#endif

/* struct saml2__NameIDType * has binding name 'PointerTosaml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_PointerTosaml2__NameIDType
#define SOAP_TYPE_PointerTosaml2__NameIDType (487)
#endif

/* struct xenc__EncryptedKeyType ** has binding name 'PointerToPointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType (486)
#endif

/* _saml1__AttributeValue has binding name '_saml1__AttributeValue' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeValue
#define SOAP_TYPE__saml1__AttributeValue (461)
#endif

/* _saml1__ConfirmationMethod has binding name '_saml1__ConfirmationMethod' for type '' */
#ifndef SOAP_TYPE__saml1__ConfirmationMethod
#define SOAP_TYPE__saml1__ConfirmationMethod (451)
#endif

/* _saml1__SubjectConfirmationData has binding name '_saml1__SubjectConfirmationData' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectConfirmationData
#define SOAP_TYPE__saml1__SubjectConfirmationData (450)
#endif

/* _saml1__Audience has binding name '_saml1__Audience' for type '' */
#ifndef SOAP_TYPE__saml1__Audience
#define SOAP_TYPE__saml1__Audience (442)
#endif

/* _saml1__AssertionIDReference has binding name '_saml1__AssertionIDReference' for type '' */
#ifndef SOAP_TYPE__saml1__AssertionIDReference
#define SOAP_TYPE__saml1__AssertionIDReference (437)
#endif

/* struct saml1__AttributeType * has binding name 'PointerTosaml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeType
#define SOAP_TYPE_PointerTosaml1__AttributeType (436)
#endif

/* struct saml1__EvidenceType * has binding name 'PointerTosaml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml1__EvidenceType
#define SOAP_TYPE_PointerTosaml1__EvidenceType (435)
#endif

/* struct saml1__ActionType * has binding name 'PointerTosaml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml1__ActionType
#define SOAP_TYPE_PointerTosaml1__ActionType (434)
#endif

/* struct saml1__AuthorityBindingType * has binding name 'PointerTosaml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorityBindingType
#define SOAP_TYPE_PointerTosaml1__AuthorityBindingType (433)
#endif

/* struct saml1__SubjectLocalityType * has binding name 'PointerTosaml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml1__SubjectLocalityType (432)
#endif

/* struct saml1__SubjectType * has binding name 'PointerTosaml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectType
#define SOAP_TYPE_PointerTosaml1__SubjectType (431)
#endif

/* struct __saml1__union_EvidenceType * has binding name 'PointerTo__saml1__union_EvidenceType' for type '-saml1:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml1__union_EvidenceType (430)
#endif

/* char ** has binding name 'PointerTostring' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostring
#define SOAP_TYPE_PointerTostring (428)
#endif

/* struct saml1__SubjectConfirmationType * has binding name 'PointerTosaml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml1__SubjectConfirmationType (427)
#endif

/* struct saml1__NameIdentifierType * has binding name 'PointerTosaml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_PointerTosaml1__NameIdentifierType
#define SOAP_TYPE_PointerTosaml1__NameIdentifierType (426)
#endif

/* struct __saml1__union_AdviceType * has binding name 'PointerTo__saml1__union_AdviceType' for type '-saml1:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AdviceType
#define SOAP_TYPE_PointerTo__saml1__union_AdviceType (425)
#endif

/* struct saml1__AssertionType * has binding name 'PointerTosaml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AssertionType
#define SOAP_TYPE_PointerTosaml1__AssertionType (424)
#endif

/* struct timeval * has binding name 'PointerToxsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerToxsd__dateTime
#define SOAP_TYPE_PointerToxsd__dateTime (422)
#endif

/* struct __saml1__union_ConditionsType * has binding name 'PointerTo__saml1__union_ConditionsType' for type '-saml1:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml1__union_ConditionsType (421)
#endif

/* struct saml1__ConditionAbstractType * has binding name 'PointerTosaml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml1__ConditionAbstractType (420)
#endif

/* struct saml1__DoNotCacheConditionType * has binding name 'PointerTosaml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType
#define SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType (419)
#endif

/* struct saml1__AudienceRestrictionConditionType * has binding name 'PointerTosaml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType
#define SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType (418)
#endif

/* struct ds__SignatureType * has binding name 'PointerTo_ds__Signature' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__Signature
#define SOAP_TYPE_PointerTo_ds__Signature (416)
#endif

/* struct __saml1__union_AssertionType * has binding name 'PointerTo__saml1__union_AssertionType' for type '-saml1:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AssertionType
#define SOAP_TYPE_PointerTo__saml1__union_AssertionType (415)
#endif

/* struct saml1__AttributeStatementType * has binding name 'PointerTosaml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeStatementType
#define SOAP_TYPE_PointerTosaml1__AttributeStatementType (414)
#endif

/* struct saml1__AuthorizationDecisionStatementType * has binding name 'PointerTosaml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType (413)
#endif

/* struct saml1__AuthenticationStatementType * has binding name 'PointerTosaml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthenticationStatementType
#define SOAP_TYPE_PointerTosaml1__AuthenticationStatementType (412)
#endif

/* struct saml1__SubjectStatementAbstractType * has binding name 'PointerTosaml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType
#define SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType (411)
#endif

/* struct saml1__StatementAbstractType * has binding name 'PointerTosaml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__StatementAbstractType
#define SOAP_TYPE_PointerTosaml1__StatementAbstractType (410)
#endif

/* struct saml1__AdviceType * has binding name 'PointerTosaml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml1__AdviceType
#define SOAP_TYPE_PointerTosaml1__AdviceType (408)
#endif

/* struct saml1__ConditionsType * has binding name 'PointerTosaml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionsType
#define SOAP_TYPE_PointerTosaml1__ConditionsType (407)
#endif

/* struct __wsc__DerivedKeyTokenType_sequence * has binding name 'PointerTo__wsc__DerivedKeyTokenType_sequence' for type '-wsc:DerivedKeyTokenType-sequence' */
#ifndef SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence (383)
#endif

/* ULONG64 * has binding name 'PointerToULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_PointerToULONG64
#define SOAP_TYPE_PointerToULONG64 (382)
#endif

/* struct wsc__PropertiesType * has binding name 'PointerTowsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_PointerTowsc__PropertiesType
#define SOAP_TYPE_PointerTowsc__PropertiesType (379)
#endif

/* wsc__FaultCodeOpenEnumType has binding name 'wsc__FaultCodeOpenEnumType' for type 'wsc:FaultCodeOpenEnumType' */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (374)
#endif

/* struct _xenc__ReferenceList * has binding name 'PointerTo_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE_PointerTo_xenc__ReferenceList
#define SOAP_TYPE_PointerTo_xenc__ReferenceList (373)
#endif

/* struct __xenc__union_ReferenceList * has binding name 'PointerTo__xenc__union_ReferenceList' for type '-xenc:union-ReferenceList' */
#ifndef SOAP_TYPE_PointerTo__xenc__union_ReferenceList
#define SOAP_TYPE_PointerTo__xenc__union_ReferenceList (372)
#endif

/* struct xenc__ReferenceType * has binding name 'PointerToxenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__ReferenceType
#define SOAP_TYPE_PointerToxenc__ReferenceType (371)
#endif

/* struct xenc__EncryptionPropertyType * has binding name 'PointerToxenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertyType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertyType (369)
#endif

/* struct xenc__TransformsType * has binding name 'PointerToxenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_PointerToxenc__TransformsType
#define SOAP_TYPE_PointerToxenc__TransformsType (368)
#endif

/* struct xenc__CipherReferenceType * has binding name 'PointerToxenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherReferenceType
#define SOAP_TYPE_PointerToxenc__CipherReferenceType (367)
#endif

/* struct xenc__EncryptionPropertiesType * has binding name 'PointerToxenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertiesType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertiesType (366)
#endif

/* struct xenc__CipherDataType * has binding name 'PointerToxenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherDataType
#define SOAP_TYPE_PointerToxenc__CipherDataType (365)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerTo_ds__KeyInfo (364)
#endif

/* struct xenc__EncryptionMethodType * has binding name 'PointerToxenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionMethodType
#define SOAP_TYPE_PointerToxenc__EncryptionMethodType (363)
#endif

/* struct ds__X509IssuerSerialType * has binding name 'PointerTods__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_PointerTods__X509IssuerSerialType
#define SOAP_TYPE_PointerTods__X509IssuerSerialType (351)
#endif

/* struct ds__RSAKeyValueType * has binding name 'PointerTods__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__RSAKeyValueType
#define SOAP_TYPE_PointerTods__RSAKeyValueType (350)
#endif

/* struct ds__DSAKeyValueType * has binding name 'PointerTods__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__DSAKeyValueType
#define SOAP_TYPE_PointerTods__DSAKeyValueType (349)
#endif

/* struct ds__TransformType * has binding name 'PointerTods__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_PointerTods__TransformType
#define SOAP_TYPE_PointerTods__TransformType (348)
#endif

/* struct ds__DigestMethodType * has binding name 'PointerTods__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_PointerTods__DigestMethodType
#define SOAP_TYPE_PointerTods__DigestMethodType (347)
#endif

/* struct ds__TransformsType * has binding name 'PointerTods__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_PointerTods__TransformsType
#define SOAP_TYPE_PointerTods__TransformsType (346)
#endif

/* struct ds__ReferenceType ** has binding name 'PointerToPointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerToPointerTods__ReferenceType
#define SOAP_TYPE_PointerToPointerTods__ReferenceType (345)
#endif

/* struct ds__ReferenceType * has binding name 'PointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerTods__ReferenceType
#define SOAP_TYPE_PointerTods__ReferenceType (344)
#endif

/* struct ds__SignatureMethodType * has binding name 'PointerTods__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_PointerTods__SignatureMethodType
#define SOAP_TYPE_PointerTods__SignatureMethodType (343)
#endif

/* struct ds__CanonicalizationMethodType * has binding name 'PointerTods__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_PointerTods__CanonicalizationMethodType
#define SOAP_TYPE_PointerTods__CanonicalizationMethodType (342)
#endif

/* struct _wsse__SecurityTokenReference * has binding name 'PointerTo_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__SecurityTokenReference
#define SOAP_TYPE_PointerTo_wsse__SecurityTokenReference (337)
#endif

/* struct ds__RetrievalMethodType * has binding name 'PointerTods__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_PointerTods__RetrievalMethodType
#define SOAP_TYPE_PointerTods__RetrievalMethodType (336)
#endif

/* struct ds__KeyValueType * has binding name 'PointerTods__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_PointerTods__KeyValueType
#define SOAP_TYPE_PointerTods__KeyValueType (334)
#endif

/* struct _c14n__InclusiveNamespaces * has binding name 'PointerTo_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces
#define SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces (330)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTods__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_PointerTods__KeyInfoType
#define SOAP_TYPE_PointerTods__KeyInfoType (322)
#endif

/* struct ds__SignedInfoType * has binding name 'PointerTods__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_PointerTods__SignedInfoType
#define SOAP_TYPE_PointerTods__SignedInfoType (321)
#endif

/* _ds__SignatureValue has binding name '_ds__SignatureValue' for type '' */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (318)
#endif

/* struct xenc__EncryptedKeyType * has binding name 'PointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToxenc__EncryptedKeyType (317)
#endif

/* struct ds__X509DataType * has binding name 'PointerTods__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_PointerTods__X509DataType
#define SOAP_TYPE_PointerTods__X509DataType (314)
#endif

/* struct _wsse__Embedded * has binding name 'PointerTo_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Embedded
#define SOAP_TYPE_PointerTo_wsse__Embedded (312)
#endif

/* struct _wsse__KeyIdentifier * has binding name 'PointerTo_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__KeyIdentifier
#define SOAP_TYPE_PointerTo_wsse__KeyIdentifier (311)
#endif

/* struct _wsse__Reference * has binding name 'PointerTo_wsse__Reference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Reference
#define SOAP_TYPE_PointerTo_wsse__Reference (310)
#endif

/* unsigned int * has binding name 'PointerTounsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_PointerTounsignedInt
#define SOAP_TYPE_PointerTounsignedInt (304)
#endif

/* struct wsse__EncodedString * has binding name 'PointerTowsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_PointerTowsse__EncodedString
#define SOAP_TYPE_PointerTowsse__EncodedString (302)
#endif

/* struct _wsse__Password * has binding name 'PointerTo_wsse__Password' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Password
#define SOAP_TYPE_PointerTo_wsse__Password (301)
#endif

/* _wsnt__ResumeSubscription * has binding name 'PointerTo_wsnt__ResumeSubscription' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__ResumeSubscription
#define SOAP_TYPE_PointerTo_wsnt__ResumeSubscription (291)
#endif

/* _wsnt__PauseSubscription * has binding name 'PointerTo_wsnt__PauseSubscription' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__PauseSubscription
#define SOAP_TYPE_PointerTo_wsnt__PauseSubscription (287)
#endif

/* _wsnt__CreatePullPoint * has binding name 'PointerTo_wsnt__CreatePullPoint' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__CreatePullPoint
#define SOAP_TYPE_PointerTo_wsnt__CreatePullPoint (279)
#endif

/* _wsnt__DestroyPullPoint * has binding name 'PointerTo_wsnt__DestroyPullPoint' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__DestroyPullPoint
#define SOAP_TYPE_PointerTo_wsnt__DestroyPullPoint (273)
#endif

/* _wsnt__GetMessages * has binding name 'PointerTo_wsnt__GetMessages' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__GetMessages
#define SOAP_TYPE_PointerTo_wsnt__GetMessages (269)
#endif

/* _wsnt__Notify * has binding name 'PointerTo_wsnt__Notify' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Notify
#define SOAP_TYPE_PointerTo_wsnt__Notify (266)
#endif

/* _wsnt__GetCurrentMessage * has binding name 'PointerTo_wsnt__GetCurrentMessage' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__GetCurrentMessage
#define SOAP_TYPE_PointerTo_wsnt__GetCurrentMessage (262)
#endif

/* _wsnt__Subscribe * has binding name 'PointerTo_wsnt__Subscribe' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Subscribe
#define SOAP_TYPE_PointerTo_wsnt__Subscribe (258)
#endif

/* _wsnt__Renew * has binding name 'PointerTo_wsnt__Renew' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Renew
#define SOAP_TYPE_PointerTo_wsnt__Renew (252)
#endif

/* _tev__GetEventBrokers * has binding name 'PointerTo_tev__GetEventBrokers' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__GetEventBrokers
#define SOAP_TYPE_PointerTo_tev__GetEventBrokers (248)
#endif

/* _tev__DeleteEventBroker * has binding name 'PointerTo_tev__DeleteEventBroker' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__DeleteEventBroker
#define SOAP_TYPE_PointerTo_tev__DeleteEventBroker (244)
#endif

/* _tev__AddEventBroker * has binding name 'PointerTo_tev__AddEventBroker' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__AddEventBroker
#define SOAP_TYPE_PointerTo_tev__AddEventBroker (240)
#endif

/* _tev__GetEventProperties * has binding name 'PointerTo_tev__GetEventProperties' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__GetEventProperties
#define SOAP_TYPE_PointerTo_tev__GetEventProperties (236)
#endif

/* _tev__CreatePullPointSubscription * has binding name 'PointerTo_tev__CreatePullPointSubscription' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription
#define SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription (232)
#endif

/* _tev__GetServiceCapabilities * has binding name 'PointerTo_tev__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_tev__GetServiceCapabilities (228)
#endif

/* _wsnt__Unsubscribe * has binding name 'PointerTo_wsnt__Unsubscribe' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Unsubscribe
#define SOAP_TYPE_PointerTo_wsnt__Unsubscribe (224)
#endif

/* _tev__SetSynchronizationPoint * has binding name 'PointerTo_tev__SetSynchronizationPoint' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__SetSynchronizationPoint
#define SOAP_TYPE_PointerTo_tev__SetSynchronizationPoint (220)
#endif

/* _tev__Seek * has binding name 'PointerTo_tev__Seek' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__Seek
#define SOAP_TYPE_PointerTo_tev__Seek (216)
#endif

/* _tev__PullMessages * has binding name 'PointerTo_tev__PullMessages' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__PullMessages
#define SOAP_TYPE_PointerTo_tev__PullMessages (212)
#endif

/* wsnt__UnsupportedPolicyRequestFaultType * has binding name 'PointerTowsnt__UnsupportedPolicyRequestFaultType' for type 'wsnt:UnsupportedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_PointerTowsnt__UnsupportedPolicyRequestFaultType (210)
#endif

/* wsnt__UnrecognizedPolicyRequestFaultType * has binding name 'PointerTowsnt__UnrecognizedPolicyRequestFaultType' for type 'wsnt:UnrecognizedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_PointerTowsnt__UnrecognizedPolicyRequestFaultType (209)
#endif

/* wsnt__UnacceptableTerminationTimeFaultType * has binding name 'PointerTowsnt__UnacceptableTerminationTimeFaultType' for type 'wsnt:UnacceptableTerminationTimeFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_PointerTowsnt__UnacceptableTerminationTimeFaultType (208)
#endif

/* wsnt__UnacceptableInitialTerminationTimeFaultType * has binding name 'PointerTowsnt__UnacceptableInitialTerminationTimeFaultType' for type 'wsnt:UnacceptableInitialTerminationTimeFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType (207)
#endif

/* wsnt__UnableToGetMessagesFaultType * has binding name 'PointerTowsnt__UnableToGetMessagesFaultType' for type 'wsnt:UnableToGetMessagesFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_PointerTowsnt__UnableToGetMessagesFaultType (206)
#endif

/* wsnt__UnableToDestroySubscriptionFaultType * has binding name 'PointerTowsnt__UnableToDestroySubscriptionFaultType' for type 'wsnt:UnableToDestroySubscriptionFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_PointerTowsnt__UnableToDestroySubscriptionFaultType (205)
#endif

/* wsnt__UnableToDestroyPullPointFaultType * has binding name 'PointerTowsnt__UnableToDestroyPullPointFaultType' for type 'wsnt:UnableToDestroyPullPointFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_PointerTowsnt__UnableToDestroyPullPointFaultType (204)
#endif

/* wsnt__UnableToCreatePullPointFaultType * has binding name 'PointerTowsnt__UnableToCreatePullPointFaultType' for type 'wsnt:UnableToCreatePullPointFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_PointerTowsnt__UnableToCreatePullPointFaultType (203)
#endif

/* wsnt__TopicNotSupportedFaultType * has binding name 'PointerTowsnt__TopicNotSupportedFaultType' for type 'wsnt:TopicNotSupportedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_PointerTowsnt__TopicNotSupportedFaultType (202)
#endif

/* wsnt__TopicExpressionDialectUnknownFaultType * has binding name 'PointerTowsnt__TopicExpressionDialectUnknownFaultType' for type 'wsnt:TopicExpressionDialectUnknownFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_PointerTowsnt__TopicExpressionDialectUnknownFaultType (201)
#endif

/* wsnt__SubscribeCreationFailedFaultType * has binding name 'PointerTowsnt__SubscribeCreationFailedFaultType' for type 'wsnt:SubscribeCreationFailedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_PointerTowsnt__SubscribeCreationFailedFaultType (200)
#endif

/* wsnt__ResumeFailedFaultType * has binding name 'PointerTowsnt__ResumeFailedFaultType' for type 'wsnt:ResumeFailedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__ResumeFailedFaultType
#define SOAP_TYPE_PointerTowsnt__ResumeFailedFaultType (199)
#endif

/* wsrfr__ResourceUnknownFaultType * has binding name 'PointerTowsrfr__ResourceUnknownFaultType' for type 'wsrfr:ResourceUnknownFaultType' */
#ifndef SOAP_TYPE_PointerTowsrfr__ResourceUnknownFaultType
#define SOAP_TYPE_PointerTowsrfr__ResourceUnknownFaultType (198)
#endif

/* _tev__PullMessagesFaultResponse * has binding name 'PointerTo_tev__PullMessagesFaultResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__PullMessagesFaultResponse
#define SOAP_TYPE_PointerTo_tev__PullMessagesFaultResponse (197)
#endif

/* wsnt__PauseFailedFaultType * has binding name 'PointerTowsnt__PauseFailedFaultType' for type 'wsnt:PauseFailedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__PauseFailedFaultType
#define SOAP_TYPE_PointerTowsnt__PauseFailedFaultType (196)
#endif

/* wsnt__NotifyMessageNotSupportedFaultType * has binding name 'PointerTowsnt__NotifyMessageNotSupportedFaultType' for type 'wsnt:NotifyMessageNotSupportedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_PointerTowsnt__NotifyMessageNotSupportedFaultType (195)
#endif

/* wsnt__NoCurrentMessageOnTopicFaultType * has binding name 'PointerTowsnt__NoCurrentMessageOnTopicFaultType' for type 'wsnt:NoCurrentMessageOnTopicFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_PointerTowsnt__NoCurrentMessageOnTopicFaultType (194)
#endif

/* wsnt__MultipleTopicsSpecifiedFaultType * has binding name 'PointerTowsnt__MultipleTopicsSpecifiedFaultType' for type 'wsnt:MultipleTopicsSpecifiedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_PointerTowsnt__MultipleTopicsSpecifiedFaultType (193)
#endif

/* wsnt__InvalidTopicExpressionFaultType * has binding name 'PointerTowsnt__InvalidTopicExpressionFaultType' for type 'wsnt:InvalidTopicExpressionFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_PointerTowsnt__InvalidTopicExpressionFaultType (192)
#endif

/* wsnt__InvalidProducerPropertiesExpressionFaultType * has binding name 'PointerTowsnt__InvalidProducerPropertiesExpressionFaultType' for type 'wsnt:InvalidProducerPropertiesExpressionFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType (191)
#endif

/* wsnt__InvalidMessageContentExpressionFaultType * has binding name 'PointerTowsnt__InvalidMessageContentExpressionFaultType' for type 'wsnt:InvalidMessageContentExpressionFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_PointerTowsnt__InvalidMessageContentExpressionFaultType (190)
#endif

/* wsnt__InvalidFilterFaultType * has binding name 'PointerTowsnt__InvalidFilterFaultType' for type 'wsnt:InvalidFilterFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__InvalidFilterFaultType
#define SOAP_TYPE_PointerTowsnt__InvalidFilterFaultType (189)
#endif

/* std::string * has binding name 'PointerToxsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_PointerToxsd__NCName
#define SOAP_TYPE_PointerToxsd__NCName (188)
#endif

/* std::string * has binding name 'PointerTowstop__ConcreteTopicExpression' for type 'wstop:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_PointerTowstop__ConcreteTopicExpression
#define SOAP_TYPE_PointerTowstop__ConcreteTopicExpression (186)
#endif

/* std::string * has binding name 'PointerToxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_PointerToxsd__QName
#define SOAP_TYPE_PointerToxsd__QName (185)
#endif

/* wstop__TopicType * has binding name 'PointerTowstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_PointerTowstop__TopicType
#define SOAP_TYPE_PointerTowstop__TopicType (183)
#endif

/* wstop__QueryExpressionType * has binding name 'PointerTowstop__QueryExpressionType' for type 'wstop:QueryExpressionType' */
#ifndef SOAP_TYPE_PointerTowstop__QueryExpressionType
#define SOAP_TYPE_PointerTowstop__QueryExpressionType (182)
#endif

/* wstop__Documentation * has binding name 'PointerTowstop__Documentation' for type 'wstop:Documentation' */
#ifndef SOAP_TYPE_PointerTowstop__Documentation
#define SOAP_TYPE_PointerTowstop__Documentation (179)
#endif

/* std::string * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_PointerToxsd__nonNegativeInteger (178)
#endif

/* _wsnt__Subscribe_SubscriptionPolicy * has binding name 'PointerTo_wsnt__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy (177)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (175)
#endif

/* wsnt__SubscriptionPolicyType * has binding name 'PointerTowsnt__SubscriptionPolicyType' for type 'wsnt:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType
#define SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType (174)
#endif

/* wsnt__TopicExpressionType * has binding name 'PointerTowsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_PointerTowsnt__TopicExpressionType
#define SOAP_TYPE_PointerTowsnt__TopicExpressionType (171)
#endif

/* _wsrfbf__BaseFaultType_FaultCause * has binding name 'PointerTo_wsrfbf__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause (170)
#endif

/* std::string * has binding name 'PointerTo_xml__lang' for type '' */
#ifndef SOAP_TYPE_PointerTo_xml__lang
#define SOAP_TYPE_PointerTo_xml__lang (167)
#endif

/* _wsrfbf__BaseFaultType_ErrorCode * has binding name 'PointerTo_wsrfbf__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode (165)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTowsa5__EndpointReferenceType' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_PointerTowsa5__EndpointReferenceType
#define SOAP_TYPE_PointerTowsa5__EndpointReferenceType (163)
#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_PointerToxsd__anyURI
#define SOAP_TYPE_PointerToxsd__anyURI (161)
#endif

/* tev__EventBrokerConfig * has binding name 'PointerTotev__EventBrokerConfig' for type 'tev:EventBrokerConfig' */
#ifndef SOAP_TYPE_PointerTotev__EventBrokerConfig
#define SOAP_TYPE_PointerTotev__EventBrokerConfig (160)
#endif

/* wstop__TopicSetType * has binding name 'PointerTowstop__TopicSetType' for type 'wstop:TopicSetType' */
#ifndef SOAP_TYPE_PointerTowstop__TopicSetType
#define SOAP_TYPE_PointerTowstop__TopicSetType (159)
#endif

/* wsnt__NotificationMessageHolderType * has binding name 'PointerTowsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType
#define SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType (156)
#endif

/* _tev__CreatePullPointSubscription_SubscriptionPolicy * has binding name 'PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy (154)
#endif

/* std::string * has binding name 'PointerTowsnt__AbsoluteOrRelativeTimeType' for type 'wsnt:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType (152)
#endif

/* tev__Capabilities * has binding name 'PointerTotev__Capabilities' for type 'tev:Capabilities' */
#ifndef SOAP_TYPE_PointerTotev__Capabilities
#define SOAP_TYPE_PointerTotev__Capabilities (151)
#endif

/* wsnt__FilterType * has binding name 'PointerTowsnt__FilterType' for type 'wsnt:FilterType' */
#ifndef SOAP_TYPE_PointerTowsnt__FilterType
#define SOAP_TYPE_PointerTowsnt__FilterType (150)
#endif

/* std::string * has binding name 'PointerToxsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_PointerToxsd__token
#define SOAP_TYPE_PointerToxsd__token (149)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (147)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (146)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (53)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (51)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (49)
#endif

/* struct chan__ChannelInstanceType * has binding name 'PointerTochan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_PointerTochan__ChannelInstanceType
#define SOAP_TYPE_PointerTochan__ChannelInstanceType (47)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__FaultTo
#define SOAP_TYPE_PointerTo_wsa5__FaultTo (46)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__ReplyTo
#define SOAP_TYPE_PointerTo_wsa5__ReplyTo (45)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__From' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__From
#define SOAP_TYPE_PointerTo_wsa5__From (44)
#endif

/* struct wsa5__RelatesToType * has binding name 'PointerTo_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__RelatesTo
#define SOAP_TYPE_PointerTo_wsa5__RelatesTo (43)
#endif

/* _wsa5__ProblemIRI has binding name '_wsa5__ProblemIRI' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (38)
#endif

/* _wsa5__ProblemHeaderQName has binding name '_wsa5__ProblemHeaderQName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (37)
#endif

/* _wsa5__Action has binding name '_wsa5__Action' for type '' */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (34)
#endif

/* _wsa5__To has binding name '_wsa5__To' for type '' */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (33)
#endif

/* _wsa5__MessageID has binding name '_wsa5__MessageID' for type '' */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (28)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (24)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (23)
#endif

/* struct wsa5__MetadataType * has binding name 'PointerTowsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_PointerTowsa5__MetadataType
#define SOAP_TYPE_PointerTowsa5__MetadataType (22)
#endif

/* struct wsa5__ReferenceParametersType * has binding name 'PointerTowsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_PointerTowsa5__ReferenceParametersType
#define SOAP_TYPE_PointerTowsa5__ReferenceParametersType (21)
#endif

/* wsa5__FaultCodesOpenEnumType has binding name 'wsa5__FaultCodesOpenEnumType' for type 'wsa5:FaultCodesOpenEnumType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (18)
#endif

/* wsa5__RelationshipTypeOpenEnum has binding name 'wsa5__RelationshipTypeOpenEnum' for type 'wsa5:RelationshipTypeOpenEnum' */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (17)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<_wstop__TopicNamespaceType_Topic>  has binding name 'std__vectorTemplateOf_wstop__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic
#define SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic (187)
#endif

/* std::vector<wstop__TopicType *>  has binding name 'std__vectorTemplateOfPointerTowstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType (184)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__QName
#define SOAP_TYPE_std__vectorTemplateOfxsd__QName (180)
#endif

/* std::vector<wsnt__TopicExpressionType *>  has binding name 'std__vectorTemplateOfPointerTowsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType (173)
#endif

/* std::vector<_wsrfbf__BaseFaultType_Description>  has binding name 'std__vectorTemplateOf_wsrfbf__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description
#define SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description (168)
#endif

/* std::vector<tev__EventBrokerConfig *>  has binding name 'std__vectorTemplateOfPointerTotev__EventBrokerConfig' for type 'tev:EventBrokerConfig' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotev__EventBrokerConfig
#define SOAP_TYPE_std__vectorTemplateOfPointerTotev__EventBrokerConfig (162)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyURI
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyURI (158)
#endif

/* std::vector<wsnt__NotificationMessageHolderType *>  has binding name 'std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType (157)
#endif

/* std::vector<struct soap_dom_element>  has binding name 'std__vectorTemplateOfxsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyType
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyType (144)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
